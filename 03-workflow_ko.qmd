---
engine: knitr
---

# 재현 가능한 워크플로 {#sec-reproducible-workflows}

::: {.callout-note}
Chapman and Hall/CRC는 2023년 7월에 이 책을 출판했습니다. [여기](https://www.routledge.com/Telling-Stories-with-Data-With-Applications-in-R/Alexander/p/book/9781032134772)에서 구매할 수 있습니다. 이 온라인 버전에는 인쇄된 내용에 대한 몇 가지 업데이트가 있습니다.
:::

**선행 학습**

- *여기 아래에서 일어난 일은 바람이 바뀌었다는 것입니다*, [@Gelman2016] 읽기
  - 재현성 위기와 사회 과학이 이에 대응하여 어떻게 변화했는지에 대한 개요를 제공하는 블로그 게시물입니다.
- *과학 컴퓨팅의 충분히 좋은 관행*, [@wilsongoodenough] 읽기
  - 컴퓨터 사용 방식에 초점을 맞춰 데이터 과학을 수행하는 방법에 대한 명확하고 쉽게 채택할 수 있는 권장 사항 세트를 제공하는 논문입니다.
- *미래의 자신과의 관계를 개선하는 방법*, [@bowers2016improve] 읽기
  - 분석에 초점을 맞춰 데이터 과학을 수행하는 방법에 대한 명확하고 쉽게 채택할 수 있는 권장 사항 세트를 제공하는 논문입니다.
- *코드 공유 장벽 극복*, [@monicatalks] 시청하기
  - 이 비디오는 코드 공유에 익숙해지는 것에 대한 개인적인 성찰입니다.
- *reprex를 만드십시오$\dots$ 제발*, [@sharlatalks] 시청하기
  - 이 비디오는 도움을 요청할 때 재현 가능한 예를 만드는 것이 왜 그렇게 중요한지 자세히 설명합니다.
- *tidyverse 스타일 가이드*, [@tidyversestyleguide] 읽기
  - R로 코딩할 때 권장되는 모범 사례 세트를 문서화하는 웹사이트입니다.
- *코드 냄새와 느낌*, [@codesmells] 시청하기
  - 코딩할 때 피해야 할 사항을 자세히 설명하는 비디오입니다.

**주요 개념 및 기술**

- 재현성은 일반적으로 누군가가 당신에게 부과하는 것으로 시작됩니다. 번거롭고 짜증스러울 수 있습니다. 이것은 일반적으로 잠시 쉬었다가 프로젝트를 다시 방문해야 할 때까지 지속됩니다. 그 시점에서 당신은 일반적으로 재현성이 진정한 발전을 이룰 수 있는 유일한 방법이기 때문에 데이터 과학의 요구 사항일 뿐만 아니라 우리 자신을 돕는 데 도움이 되기 때문이라는 것을 깨닫게 됩니다.
- 재현성은 데이터, 코드 및 환경 공유를 의미합니다. 이는 Quarto, R 프로젝트, Git 및 GitHub를 사용하여 향상됩니다. Quarto는 일반 텍스트와 R 코드를 통합하는 문서를 빌드합니다. R 프로젝트는 사용자의 개인 디렉터리 설정에 의존하지 않는 파일 구조를 가능하게 합니다. Git 및 GitHub는 코드와 데이터를 더 쉽게 공유할 수 있도록 합니다.
- 이것은 완벽한 워크플로는 아니지만 충분히 좋고 많은 이점을 제공하는 워크플로입니다. 다양한 도구를 통해 다양한 측면을 개선하겠지만 코드 구조와 주석을 개선하는 것만으로도 많은 도움이 됩니다.
- 항상 오류가 발생하며 디버깅은 연습을 통해 향상되는 기술이라는 것을 인식하는 것이 중요합니다. 그러나 도움을 받을 수 있는 핵심 측면 중 하나는 다른 사람이 사용할 수 있는 재현 가능한 예를 만들 수 있다는 것입니다.

**소프트웨어 및 패키지**

- 기본 R [@citeR]
- `AER` [@citeaer]
- `future` [@future]
- `gitcreds` [@gitcreds]
- `lintr` [@lintr]
- `renv` [@renv]
- `reprex` [@reprex]
- `styler` [@styler]
- `tidyverse` [@tidyverse]
- `tinytable` [@tinytable]
- `tinytex` [@tinytex]
- `usethis` [@usethis]

```{r}
#| message: false
#| warning: false

library(AER)
library(future)
library(gitcreds)
library(lintr)
library(renv)
library(reprex)
library(styler)
library(tidyverse)
library(tinytable)
library(tinytex)
library(usethis)
```


## 소개

> 머신 러닝에 대해 명심해야 할 첫 번째 사항은 성능이 하나의 데이터셋의 샘플에서 평가되지만 모델은 반드시 동일한 특성을 따르지 않을 수 있는 샘플에서 프로덕션 환경에서 사용된다는 것입니다$\dots$ 따라서 "90% 정확도로 평가된 모델을 사용하시겠습니까, 아니면 80% 정확도로 평가된 인간을 사용하시겠습니까?"라는 질문을 할 때 답은 데이터가 평가 프로세스에 따라 일반적인지 여부에 따라 달라집니다. 인간은 적응력이 있지만 모델은 그렇지 않습니다. 상당한 불확실성이 관련된 경우 인간을 선택하십시오. 그들은 (엄청난 양의 데이터로 훈련된 모델에 비해) 패턴 인식 능력이 떨어질 수 있지만 자신이 하는 일을 이해하고 그것에 대해 추론할 수 있으며 새로움에 직면했을 때 즉흥적으로 대처할 수 있습니다.
>
> 프랑수아 숄레, 2020년 2월 20일.

과학이 검증 가능한 설명과 예측의 관점에서 지식을 체계적으로 구축하고 조직하는 것이라면, 데이터 과학은 이를 데이터에 집중합니다. 이는 지식을 구축, 조직 및 공유하는 것이 중요한 측면임을 의미합니다. 당신만이 할 수 있는 방식으로 한 번 지식을 창출하는 것은 이 기준을 충족하지 못합니다. 따라서 재현 가능한 데이터 과학 워크플로가 필요합니다.

@Alexander2019는 재현 가능한 연구\index{reproducibility}를 사용된 모든 자료가 주어지면 정확하게 다시 수행할 수 있는 연구로 정의합니다. 이는 코드, 데이터 및 환경을 제공하는 것의 중요성을 강조합니다. 최소한의 기대는 다른 사람이 독립적으로 귀하의 코드, 데이터 및 환경을 사용하여 그림과 표를 포함한 결과를 얻을 수 있다는 것입니다. 아이러니하게도 분야마다 재현성에 대한 정의가 다릅니다. @barba2018terminologies는 다양한 분야를 조사하고 주요 언어 사용이 다음 정의를 의미한다고 결론 내립니다.

- 재현 가능한 연구는 "[저자가] 분석을 다시 실행하고 결과를 재현하는 데 필요한 모든 데이터와 컴퓨터 코드를 제공하는 경우"입니다.
- 복제는 "새로운 데이터(아마도 다른 방법 사용)를 수집하고 새로운 분석을 완료하여 다른 연구와 동일한 과학적 발견에 도달하는 연구"입니다.

우리의 목적을 위해 @nationalacademies [p. 46]의 정의를 사용합니다. "재현성이란 동일한 입력 데이터, 계산 단계, 방법 및 코드, 분석 조건을 사용하여 일관된 결과를 얻는 것입니다."\index{reproducibility!definition} 구체적으로 무엇이라고 불리든 @Gelman2016은 다양한 사회 과학에서 그것의 부족이 얼마나 큰 문제인지 확인합니다. 재현할 수 없는 작업은 세상에 대한 우리의 지식 축적에 기여하지 않습니다. 이것은 낭비적이며 잠재적으로 비윤리적일 수도 있습니다. @Gelman2016 이후 많은 사회 과학에서 많은 작업이 이루어졌고 상황이 약간 개선되었지만 아직 많은 작업이 남아 있습니다. 이는 생명 과학[@heil2021reproducibility], 암 연구[@Begley2012; @Mullard2021] 및 컴퓨터 과학[@pineau2021improving]에서도 마찬가지입니다.\index{computer science}

@Gelman2016이 언급한 예 중 일부는 전체적인 관점에서 그렇게 중요하지 않습니다. 그러나 동시에 우리는 큰 영향을 미치는 분야에서 유사한 접근 방식이 사용되는 것을 보았고 계속 보고 있습니다. 예를 들어, 많은 정부는 일부 주장에 신뢰성이 부족하다는 증거가 있음에도 불구하고 공공 정책을 시행하는 "넛지" 단위를 만들었습니다[@sunstein2017economics; @nonudge; @gelmannudge].\index{public policy} 정부는 공개하지 않는 알고리즘을 점점 더 많이 사용하고 있습니다[@chouldechova18a]. 그리고 @herndon2014does는 2007-2008년 금융 위기 이후 정부가 긴축 정책을 정당화하는 데 사용한 경제학 연구가 재현 불가능하다는 것을 문서화했습니다.\index{economics}

최소한, 그리고 몇 가지 예외를 제외하고, 우리는 코드, 데이터셋 및 환경을 공개해야 합니다.\index{reproducibility!minimum} 이것들이 없으면 발견이 무엇을 의미하는지 알기 어렵습니다[@miyakawa2020no]. 더 평범하게 말하면, 실수나 부주의하게 간과된 측면이 있는지 여부도 알 수 없습니다[@merali2010computational; @hillelwayne; @natefixesmistake]. 점점 더 @buckheit1995wavelab을 따라 논문을 광고로 간주하고 관련 코드, 데이터 및 환경을 실제 작업으로 간주합니다. Apple의 공동 창립자인 스티브 잡스는\index{Apple} 자신의 기술 분야에서 최고인 사람들은 다른 누구도 볼 수 없는 작업의 측면조차도 공개된 측면만큼 잘 마무리되고 고품질인지 확인한다고 말했습니다[@stevejobs]. 데이터 과학에서도 마찬가지이며, 종종 고품질 작업의 구별되는 측면 중 하나는 README와 코드 주석이 관련 논문의 초록만큼이나 세련되었다는 것입니다.

워크플로\index{workflow}\index{ethics!culture and social context}는 문화적, 사회적 맥락 내에 존재하며, 이는 재현 가능해야 할 필요성에 대한 추가적인 윤리적 이유를 부과합니다. 예를 들어, @wang2018deep은 동성애자와 이성애자 남성의 얼굴을 구별하기 위해 신경망을 훈련시킵니다. (@murphy2017은 논문, 관련 문제 및 저자의 의견에 대한 요약을 제공합니다.) 이를 위해 @wang2018deep [p. 248]은 "성인, 백인, 완전히 보이는, 사용자의 프로필에 보고된 성별과 일치하는 성별"인 사람들의 사진 데이터셋이 필요했습니다. 그들은 특정 작업을 완료하기 위해 근로자에게 소량의 돈을 지불하는 온라인 플랫폼인 Amazon Mechanical Turk\index{Amazon!Mechanical Turk}를 사용하여 이를 확인했습니다. 이 작업에 대한 Mechanical Turk 근로자에게 제공된 지침은 백인 어머니와 흑인 아버지를 둔 제44대 미국 대통령 버락 오바마를 "흑인"으로 분류해야 하며, 라틴계는 인종이 아닌 민족이라는 점을 명시합니다[@Mattson2017].\index{bias!race} 분류 작업은 객관적으로 보일 수 있지만, 아마도 무심코 특정 계층과 배경을 가진 미국인의 견해를 반영합니다.

이것은 @wang2018deep 워크플로의 한 부분에 대한 한 가지 구체적인 우려 사항일 뿐입니다. @Gelman_2018을 포함한 다른 사람들은 더 광범위한 우려를 제기합니다. 주요 문제는 통계 모델이 훈련된 데이터에 특정하다는 것입니다.\index{data!ethics} 그리고 @wang2018deep 모델에서 발생 가능한 문제를 식별할 수 있는 유일한 이유는 그들이 사용한 특정 데이터셋을 공개하지 않았음에도 불구하고 절차에 대해 공개했기 때문입니다. 우리 작업이 신뢰할 수 있으려면 다른 사람이 재현할 수 있어야 합니다.

작업의 재현성을 높이기 위해 취할 수 있는 몇 가지 단계는 다음과 같습니다.\index{reproducibility}

1. 전체 워크플로가 문서화되었는지 확인합니다. 여기에는 다음과 같은 질문에 답하는 것이 포함될 수 있습니다.
    - 원본, 편집되지 않은 데이터셋은 어떻게 얻었으며 다른 사람이 액세스할 수 있고 지속적으로 사용할 수 있습니까?
    - 원본, 편집되지 않은 데이터를 분석된 데이터로 변환하기 위해 어떤 구체적인 단계를 수행하고 있으며 이를 다른 사람에게 어떻게 제공할 수 있습니까?
    - 어떤 분석이 수행되었으며 이를 얼마나 명확하게 공유할 수 있습니까?
    - 최종 논문이나 보고서는 어떻게 작성되었으며 다른 사람이 그 과정을 어느 정도까지 따를 수 있습니까?
2. 처음에는 완벽한 재현성에 대해 걱정하지 않고 대신 각 연속적인 프로젝트를 통해 개선하려고 노력하는 데 집중합니다. 예를 들어, 다음 각 요구 사항은 점점 더 부담스러워지며 첫 번째 요구 사항을 수행할 수 있을 때까지 마지막 요구 사항을 수행할 수 없는 것에 대해 걱정할 필요가 없습니다.
    - 전체 워크플로를 다시 실행할 수 있습니까?
    - 다른 사람이 전체 워크플로를 다시 실행할 수 있습니까?
    - "미래의 당신"이 전체 워크플로를 다시 실행할 수 있습니까?
    - "미래의 다른 사람"이 전체 워ك플로를 다시 실행할 수 있습니까?
3. 최종 논문이나 보고서에 데이터셋과 접근 방식의 한계에 대한 자세한 논의를 포함합니다.

이 책에서 우리가 주장하는 워크플로\index{workflow}는 다음과 같습니다.

$$
\mbox{계획}\rightarrow\mbox{시뮬레이션}\rightarrow\mbox{수집}\rightarrow\mbox{탐색}\rightarrow\mbox{공유}
$$

그러나 "주로 읽고 쓰고, 때로는 코딩하는 등 엄청나게 많이 생각한다"고 달리 생각할 수도 있습니다.

이 워크플로의 재현성을 향상시키는 데 사용할 수 있는 다양한 단계에서 다양한 도구가 있습니다. 여기에는 Quarto, R 프로젝트, Git 및 GitHub가 포함됩니다.

## 콰르토

### 시작하기

Quarto\index{Quarto}는 "문학적 프로그래밍"이라고 불리는 방식으로 코드와 자연어를 통합합니다[@Knuth1984]. 이는 R 코드 청크를 포함할 수 있도록 특별히 설계된 Markdown의 변형인 R Markdown의 후속 제품입니다. Quarto는 Microsoft Word와 같은 "보는 대로 얻는 것"(WYSIWYG) 언어와 비교하여 하이퍼텍스트 마크업 언어(HTML) 또는 LaTeX와 유사한 마크업 언어를 사용합니다. 즉, 모든 측면이 일관되며, 예를 들어 모든 최상위 제목은 동일하게 보입니다. 그러나 특정 측면이 어떻게 나타나기를 원하는지 지정하거나 "마크업"해야 합니다. 그리고 문서를 렌더링할 때만 어떻게 보이는지 알 수 있습니다. 시각적 편집기 옵션도 사용할 수 있으며, 이는 사용자가 직접 이 마크업을 수행할 필요성을 숨깁니다.

::: {.content-visible when-format="pdf"}
앞으로는 Quarto를 사용하는 것이 합리적이지만 R Markdown으로 작성된 많은 리소스가 있습니다.\index{R!R Markdown} 이러한 이유로 ["R Markdown" 온라인 부록](https://tellingstorieswithdata.com/22-rmarkdown.html)에서 R Markdown에 상응하는 내용을 제공합니다.
:::

::: {.content-visible unless-format="pdf"}
앞으로는 Quarto를 사용하는 것이 합리적이지만, R Markdown으로 작성된 많은 자료가 있습니다.\index{R!R Markdown} 이러한 이유로 [온라인 부록 -@sec-rmarkdown]에서 R Markdown에 해당하는 내용을 제공합니다.
:::

:::{.callout-note}
## 거인의 어깨 위에 서서

페르난도 페레즈\index{Pérez, Fernando}는 캘리포니아 대학교 버클리 캠퍼스의\index{Berkeley} 통계학 부교수이자 로렌스 버클리 국립 연구소 데이터 과학 및 기술 부서의\index{statistics} 교수 과학자입니다. 그는 콜로라도 대학교 볼더에서 입자 물리학 박사 학위를 받았습니다. 박사 과정 중에 Python을 대화형으로 사용할 수 있게 해주는 iPython을 만들었으며, 현재 R Markdown 및 Quarto와 같은 유사한 노트북 접근 방식의 기반이 되는 Project Jupyter의 기초가 되었습니다. @somers2018obsolete는 오픈 소스 노트북 접근 방식이 어떻게 극적으로 개선된 과학 컴퓨팅을 가져오는 선순환 피드백 루프를 만드는지 설명합니다. 그리고 @romersays는 Jupyter와 같은 오픈 소스 접근 방식의 특징을 과학적 합의와 발전을 가능하게 하는 특징과 일치시킵니다. 2017년 페레즈는 ACM(Association for Computing Machinery) 소프트웨어 시스템 상을 수상했습니다.
:::

문학적 프로그래밍의 한 가지 장점은 코드가 실행되고 문서의 일부를 형성하는 "라이브" 문서를 얻는다는 것입니다. Quarto의 또 다른 장점은 유사한 코드가 HTML 및 PDF를 포함한 다양한 문서로 컴파일될 수 있다는 것입니다. Quarto에는 제목, 작성자 및 날짜를 포함하기 위한 기본 옵션도 있습니다. 한 가지 단점은 코드를 실행해야 하므로 문서가 컴파일되는 데 시간이 걸릴 수 있다는 것입니다.

[여기](https://quarto.org/docs/get-started/)에서 Quarto를 다운로드해야 합니다. (Posit Cloud를 사용하는 경우 이미 설치되어 있으므로 이 단계를 건너뛰십시오.) 그런 다음 RStudio 내에서 새 Quarto 문서를 만들 수 있습니다. "파일" $\rightarrow$ "새 파일" $\rightarrow$ "Quarto 문서$\dots$".

새 Quarto 문서를 열고 "소스" 보기를 선택하면 세 개의 대시 쌍 내에 포함된 기본 [상단 내용](#상단-내용)과 몇 가지 마크다운 [필수 명령](#필수-명령) 및 [R 청크](#R-청크)를 보여주는 텍스트 예제가 표시되며, 각 내용은 다음 섹션에서 자세히 설명합니다.

### 상단 내용

상단 내용은 제목, 작성자, 날짜와 같은 측면을 정의하는 것으로 구성됩니다. Quarto 문서 상단의 세 개의 대시 안에 포함됩니다. 예를 들어, 다음은 제목, 문서가 렌더링된 날짜로 자동 업데이트되는 날짜, 작성자를 지정합니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%Y년 %B %d일")
format: html
---
```

초록은 논문의 짧은 요약이며, 상단 내용에 추가할 수 있습니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%Y년 %B %d일")
abstract: "이것은 내 초록입니다."
format: html
---
```

기본적으로 Quarto는 HTML 문서를 만들지만 출력 형식을 변경하여 PDF를 생성할 수 있습니다. 이는 백그라운드에서 LaTeX를 사용하며 지원 패키지를 설치해야 합니다. 이렇게 하려면 `tinytex`를 설치하십시오. 그러나 백그라운드에서 사용되므로 로드할 필요는 없습니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%Y년 %B %d일")
abstract: "이것은 내 초록입니다."
format: pdf
---
```

### 참고 문헌

상단 내용에 BibTeX\index{BibTeX} 파일을 지정한 다음 필요에 따라 텍스트 내에서 호출하여 참조를 포함할 수 있습니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%Y년 %B %d일")
format: pdf
abstract: "이것은 내 초록입니다."
bibliography: bibliography.bib
---
```

"bibliography.bib"라는 별도의 파일을 만들고 Quarto 파일 옆에 저장해야 합니다.\index{citation!BibTeX} BibTeX 파일에는 참조할 항목에 대한 항목이 필요합니다. 예를 들어, R에 대한 인용은 `citation()`으로 얻을 수 있으며 이를 "bibliography.bib" 파일에 추가할 수 있습니다.\index{citation!R} 패키지에 대한 인용은 패키지 이름을 포함하여 찾을 수 있습니다(예: `citation("tidyverse")`). 그리고 다시 출력을 ".bib" 파일에 추가합니다.\index{citation!R packages} 책이나 기사에 대한 인용을 얻기 위해 [Google Scholar](https://scholar.google.com) 또는 [doi2bib](https://www.doi2bib.org)을 사용하는 것이 도움이 될 수 있습니다.\index{citation!Google Scholar}\index{citation!doi2bib}

텍스트에서 이 항목을 참조하는 데 사용할 고유 키를 만들어야 합니다.\index{citation!unique key} 고유하기만 하면 무엇이든 될 수 있지만 의미 있는 키는 기억하기 더 쉬울 수 있습니다(예: "citeR").

```
@Manual{citeR,
    title = {R: A Language and Environment for Statistical Computing},
    author = {{R Core Team}},
    organization = {R Foundation for Statistical Computing},
    address = {Vienna, Austria},
    year = {2021},
    url = {https://www.R-project.org/},
  }
@book{tellingstories,
    title = {Telling Stories with Data},
    author = {Rohan Alexander},
    year = {2023},
    publisher = {Chapman and Hall/CRC},
    url = {https://tellingstorieswithdata.com}
  }
```

Quarto 문서에서 R을 인용하려면\index{citation} `@citeR`을 포함합니다. 그러면 연도 주위에 괄호가 표시됩니다: @citeR. 또는 `[@citeR]`을 포함하면 전체 항목 주위에 괄호가 표시됩니다: [@citeR].

논문 끝의 참고 문헌 목록\index{citation}은 BibTeX 파일을 호출하고 논문에 참고 문헌을 포함하는 것을 기반으로 자동으로 작성됩니다. Quarto 문서 끝에 "# 참고 문헌"이라는 제목을 포함하면 그 뒤에 실제 인용이 포함됩니다. Quarto 파일이 렌더링되면 Quarto는 내용에서 이를 보고 BibTeX 파일로 이동하여 필요한 참고 문헌 세부 정보를 가져오고 참고 문헌 목록을 작성한 다음 렌더링된 문서 끝에 추가합니다.

BibTeX\index{BibTeX!capitalization}은 항목의 대소문자를 조정하려고 시도합니다. 이것은 도움이 될 수 있지만 때로는 특정 대소문자를 고집하는 것이 더 좋습니다. BibTeX이 특정 대소문자를 사용하도록 하려면 항목 주위에 단일 중괄호 대신 이중 중괄호를 사용하십시오. 예를 들어, 위의 예에서 `{{R Core Team}}`은 정확한 대소문자로 인쇄되는 반면 `{Telling Stories with Data}`는 BibTeX의 변덕에 따라 달라집니다. 특정 대소문자를 고집하는 것은 특정 대소문자를 가질 수 있는 R 패키지를 인용할 때와 조직을 저자로 인용할 때 중요합니다. 예를 들어, `usethis`를 인용할 때 `title = {usethis: Automate Package and Project Setup},`이 아니라 `title = {{usethis: Automate Package and Project Setup}},`을 사용해야 합니다. 그리고 예를 들어 토론토 시에서 데이터를 제공한 경우 해당 데이터셋을 인용하기 위해 저자를 지정할 때 `author = {City of Toronto},`가 아니라 `author = {{City of Toronto}},`를 사용해야 합니다. 후자는 잘못된 참고 문헌 목록 항목 "Toronto, City of"를 초래하는 반면 전자는 올바른 참고 문헌 목록 항목 "City of Toronto"를 초래합니다.


### 필수 명령

Quarto\index{Quarto}는 기본 구문으로 Markdown의 변형을 사용합니다. 필수 Markdown 명령에는 강조, 머리글, 목록, 링크 및 이미지에 대한 명령이 포함됩니다. 이에 대한 알림은 RStudio에 포함되어 있습니다. "도움말" $\rightarrow$ "Markdown 빠른 참조". 시각적 편집기 또는 소스 편집기를 사용할지 여부는 사용자의 선택입니다. 그러나 어느 쪽이든 이러한 필수 사항을 이해하는 것이 좋습니다. 왜냐하면 항상 시각적 편집기를 사용할 수 있는 것은 아니기 때문입니다(예: GitHub에서 Quarto 문서를 빠르게 보는 경우). 경험이 많아지면 Sublime Text와 같은 텍스트 편집기나 VS Code와 같은 대체 통합 개발 환경을 사용하는 것이 유용할 수 있습니다.

- 강조: ```*기울임꼴*```, ```**굵게**```
- 머리글 (이것들은 앞뒤에 빈 줄이 있는 자체 줄에 표시됩니다):
```
         # 첫 번째 수준 머리글

         ## 두 번째 수준 머리글

         ### 세 번째 수준 머리글
```
- 하위 목록이 있는 정렬되지 않은 목록:
```
    * 항목 1
    * 항목 2
        + 항목 2a
        + 항목 2b
```
- 하위 목록이 있는 정렬된 목록:
```
    1. 항목 1
    2. 항목 2
    3. 항목 3
        + 항목 3a
        + 항목 3b
```
- URL을 추가할 수 있습니다: ```[이 책](https://www.tellingstorieswithdata.com)``` 결과는 [이 책](https://www.tellingstorieswithdata.com)입니다.
- 단락은 빈 줄을 남겨 만듭니다.
```
아이디어에 대한 단락, 다음 단락과 적절한 간격으로 배치됩니다.

다른 아이디어에 대한 단락, 이전 단락과 다시 간격이 있습니다.
```

일부 측면을 추가한 후에는 실제 문서를 보고 싶을 수 있습니다. 문서를 빌드하려면 "렌더링"을 클릭하십시오.



### R 청크

Quarto 문서 내의 코드 청크에 R 및 기타 여러 언어에 대한 코드를 포함할 수 있습니다. 문서를 렌더링하면 코드가 실행되고 문서에 포함됩니다.

R 청크\index{Quarto!R}를 만들려면 세 개의 백틱으로 시작한 다음 중괄호 안에 이것이 R 청크임을 Quarto에 알립니다. 이 청크 안의 모든 것은 R 코드로 간주되어 실행됩니다. *Applied Econometrics with R*이라는 책과 함께 R 패키지 `AER`을 제공하는 @citeaer의 데이터를 사용합니다. `tidyverse`를 로드하고 `AER`을 설치 및 로드한 다음 지난 2주 동안 설문 조사 응답자가 의사를 방문한 횟수에 대한 그래프를 만들 수 있습니다.

```{verbatim, file="inputs/rmarkdown_example.Rmd"}
```

해당 코드의 출력은 @fig-doctervisits입니다.

```{r}
#| label: fig-doctervisits
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| fig-cap: "지난 2주간 질병 발생 건수, 1977-1978년 호주 건강 조사 기준"

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

청크에서 사용할 수 있는 다양한 평가 옵션이 있습니다\index{Quarto!R}. 청크별 주석 구분 기호 "#|"로 줄을 열고 옵션을 사용하여 각 줄에 이러한 옵션을 포함합니다. 유용한 옵션은 다음과 같습니다.

- ```echo```: 코드 자체가 문서에 포함되는지 여부를 제어합니다. 예를 들어, ```#| echo: false```는 코드가 실행되고 출력이 표시되지만 코드 자체는 문서에 포함되지 않음을 의미합니다.
- ```include```: 코드의 출력이 문서에 포함되는지 여부를 제어합니다. 예를 들어, ```#| include: false```는 코드를 실행하지만 출력이 발생하지 않으며 코드 자체도 문서에 포함되지 않음을 의미합니다.
- ```eval```: 코드가 문서에 포함되어야 하는지 여부를 제어합니다. 예를 들어, ```#| eval: false```는 코드가 실행되지 않으므로 포함할 출력이 없지만 코드 자체는 문서에 포함됨을 의미합니다.
- ```warning```: 경고가 문서에 포함되어야 하는지 여부를 제어합니다. 예를 들어, ```#| warning: false```는 경고가 포함되지 않음을 의미합니다.
- ```message```: 메시지가 문서에 포함되어야 하는지 여부를 제어합니다. 예를 들어, ```#| message: false```는 메시지가 문서에 포함되지 않음을 의미합니다.

예를 들어, 출력은 포함하지만 코드는 포함하지 않고 경고는 표시하지 않을 수 있습니다.

```{verbatim, file="inputs/rmarkdown_example_with_options.Rmd"}
```

R 청크 양쪽에 빈 줄을 남겨두십시오. 그렇지 않으면 제대로 실행되지 않을 수 있습니다. 그리고 논리 값에는 소문자를 사용하십시오(예: "FALSE"가 아닌 "false").

```{verbatim, file="inputs/rmarkdown_example_with_blankline.Rmd"}
```

Quarto 문서 자체는 필요한 모든 데이터셋을 로드해야 합니다. 환경에 있는 것만으로는 충분하지 않습니다. 이는 Quarto 문서가 렌더링될 때 문서의 코드를 평가하며 반드시 환경을 평가하는 것은 아니기 때문입니다.

종종 코드를 작성할 때 여러 줄에 걸쳐 동일한 변경을 하거나 특정 항목의 모든 인스턴스를 변경하고 싶을 수 있습니다. 여러 커서를 사용하여 이를 달성합니다. 여러 연속된 줄에 걸쳐 커서를 원하면 Mac에서는 "option"을, PC에서는 "Alt"를 누른 상태에서 관련 줄 위로 커서를 드래그합니다. 특정 항목의 모든 인스턴스를 선택하려면 한 인스턴스(예: 변수 이름)를 강조 표시한 다음 찾기/바꾸기(Mac에서는 Command + F, PC에서는 CTRL + F)를 사용하고 "모두"를 선택합니다. 그러면 다른 모든 인스턴스에 커서가 활성화됩니다.

### 방정식 {#sec-equations}

TeX 프로그래밍 언어를 기반으로 하는 LaTeX\index{LaTeX}를 사용하여 방정식\index{equations!LaTeX}\index{Quarto!equations}을 포함할 수 있습니다. LaTeX에서 수학 모드는 두 개의 달러 기호를 여는 태그와 닫는 태그로 사용하여 호출합니다. 그런 다음 안에 있는 모든 것이 LaTeX 마크업으로 평가됩니다. 예를 들어 복리 이자 공식은 다음과 같이 생성할 수 있습니다.

``` markdown
$$
A = P\left(1+\frac{r}{n}\right)^{nt}
$$
```

$$
A = P\left(1+\frac{r}{n}\right)^{nt}
$$

LaTeX는 포괄적인 마크업 언어이지만 주로 관심 모델을 지정하는 데 사용할 것입니다. @sec-its-just-a-linear-model에서 시작하여 활용할 중요한 측면을 포함하는 몇 가지 예를 여기에 포함합니다.

``` markdown
$$
y_i|\mu_i, \sigma \sim \mbox{Normal}(\mu_i, \sigma)
$$
```

$$
y_i|\mu_i, \sigma \sim \mbox{Normal}(\mu_i, \sigma)
$$

아래 첨자는 밑줄을 사용하여 만듭니다: $y_i$의 경우 `y_i`. 그리고 중괄호로 둘러싸서 둘 이상의 항목으로 된 아래 첨자를 만들 수 있습니다: $y_{i,c}$의 경우 `y_{i,c}`. 이 경우 줄 안에 수학 모드가 필요했으므로 여는 태그와 닫는 태그로 단일 달러 기호로 둘러쌉니다.

그리스 문자는 일반적으로 백슬래시가 앞에 옵니다.\index{equations!Greek letters} 일반적인 그리스 문자는 다음과 같습니다: $\alpha$의 경우 `\alpha`, $\beta$의 경우 `\beta`, $\delta$의 경우 `\delta`, $\epsilon$의 경우 `\epsilon`, $\gamma$의 경우 `\gamma`, $\lambda$의 경우 `\lambda`, $\mu$의 경우 `\mu`, $\phi$의 경우 `\phi`, $\pi$의 경우 `\pi`, $\Pi$의 경우 `\Pi`, $\rho$의 경우 `\rho`, $\sigma$의 경우 `\sigma`, $\Sigma$의 경우 `\Sigma`, $\tau$의 경우 `\tau`, $\theta$의 경우 `\theta`.

LaTeX 수학 모드는 문자를 변수로 간주하여 기울임꼴로 만들지만, "Normal"과 같이 변수가 아니기 때문에 일반 글꼴로 표시하고 싶을 때가 있습니다. 이 경우 `\mbox{}`로 둘러쌉니다(예: $\mbox{Normal}$의 경우 `\mbox{Normal}`).

`\begin{aligned}`와 `\end{aligned}`를 사용하여 여러 줄에 걸쳐 방정식을 정렬합니다. 그런 다음 정렬할 항목은 앰퍼샌드로 표시합니다. 다음은 @sec-multilevel-regression-with-post-stratification에서 추정할 모델입니다.\index{equations!multiple lines}

``` markdown
$$
\begin{aligned}
y_i|\pi_i & \sim \mbox{Bern}(\pi_i) \\
\mbox{logit}(\pi_i) & = \beta_0+ \alpha_{g[i]}^{\mbox{gender}} + \alpha_{a[i]}^{\mbox{age}} + \alpha_{s[i]}^{\mbox{state}} + \alpha_{e[i]}^{\mbox{edu}} \\
\beta_0 & \sim \mbox{Normal}(0, 2.5)\\
\alpha_{g}^{\mbox{gender}} & \sim \mbox{Normal}(0, 2.5)\mbox{ for }g=1, 2\\
\alpha_{a}^{\mbox{age}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{age}}\right)\mbox{ for }a = 1, 2, \dots, A\\
\alpha_{s}^{\mbox{state}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{state}}\right)\mbox{ for }s = 1, 2, \dots, S\\
\alpha_{e}^{\mbox{edu}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{edu}}\right)\mbox{ for }e = 1, 2, \dots, E\\
\sigma_{\mbox{gender}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{state}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{edu}} & \sim \mbox{Exponential}(1)
\end{aligned}
$$
```

$$
\begin{aligned}
y_i|\pi_i & \sim \mbox{Bern}(\pi_i) \\
\mbox{logit}(\pi_i) & = \beta_0+ \alpha_{g[i]}^{\mbox{gender}} + \alpha_{a[i]}^{\mbox{age}} + \alpha_{s[i]}^{\mbox{state}} + \alpha_{e[i]}^{\mbox{edu}} \\
\beta_0 & \sim \mbox{Normal}(0, 2.5)\\
\alpha_{g}^{\mbox{gender}} & \sim \mbox{Normal}(0, 2.5)\mbox{ for }g=1, 2\\
\alpha_{a}^{\mbox{age}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{age}}\right)\mbox{ for }a = 1, 2, \dots, A\\
\alpha_{s}^{\mbox{state}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{state}}\right)\mbox{ for }s = 1, 2, \dots, S\\
\alpha_{e}^{\mbox{edu}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{edu}}\right)\mbox{ for }e = 1, 2, \dots, E\\
\sigma_{\mbox{gender}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{state}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{edu}} & \sim \mbox{Exponential}(1)
\end{aligned}
$$

마지막으로 특정 함수는 LaTeX에 내장되어 있습니다. 예를 들어, `\log`를 사용하여 "log"를 적절하게 조판할 수 있습니다.

### 상호 참조 {#sec-quartocrossreferences}

그림, 표, 방정식을 상호 참조\index{Quarto!cross-references}하는 것이 유용할 수 있습니다. 이렇게 하면 텍스트에서 해당 항목을 더 쉽게 참조할 수 있습니다. 그림에 대해 이 작업을 수행하려면 그림을 만들거나 포함하는 R 청크의 이름을 참조합니다. 예를 들어 다음 코드를 고려하십시오.\index{graphs!cross-references}

::: {.content-visible when-format="pdf"}
```{r}
#| echo: fenced
#| label: fig-theuniquename
#| fig-cap: 지난 2주간의 질병 발생 건수
#| warning: false

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

그런 다음 `(@fig-theuniquename)`은 R 청크의 레이블이 `fig-theuniquename`이므로 (@fig-theuniquename)을 생성합니다. Quarto가 이것이 그림임을 알 수 있도록 청크 이름 시작 부분에 "fig"를 추가해야 합니다. 그런 다음 캡션을 지정하는 R 청크에 "fig-cap:"을 포함합니다.
:::

::: {.content-visible unless-format="pdf"}
```{r}
#| echo: fenced
#| label: fig-uniquename
#| fig-cap: 1977-1978년 호주 건강 조사를 기반으로 한 지난 2주간의 질병 발생 건수
#| warning: false

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

그러면 `(@fig-uniquename)`은 R 청크의 이름이 `fig-uniquename`이므로 (@fig-uniquename)을 생성합니다. Quarto가 이것이 그림임을 알 수 있도록 청크 이름 시작 부분에 "fig"를 추가해야 합니다. 그런 다음 캡션을 지정하는 R 청크에 "fig-cap:"을 포함합니다.
:::



Quarto 문서 내의 R 청크에 `#| layout-ncol: 2`를 추가하여 두 개의 그래프가 나란히 나타나도록 할 수 있습니다(@fig-doctorgraphsidebyside).\index{graphs!sub-figures} 여기서 @fig-doctorgraphsidebyside-1은 최소 테마를 사용하고 @fig-doctorgraphsidebyside-2는 클래식 테마를 사용합니다. 이들은 모두 R 청크에서 동일한 레이블 `#| label: fig-doctorgraphsidebyside`을 상호 참조하며, R 청크에 추가 옵션 `#| fig-subcap: ["질병 수","의사 방문 횟수"]`가 추가되어 하위 캡션을 제공합니다. 텍스트 내 문자는 레이블 끝에 "-1"과 "-2"를 추가하여 수행됩니다. 각각 (@fig-doctorgraphsidebyside), @fig-doctorgraphsidebyside-1 및 @fig-doctorgraphsidebyside-2의 경우 `(@fig-doctorgraphsidebyside)`, `@fig-doctorgraphsidebyside-1` 및 `@fig-doctorgraphsidebyside-2`입니다.

```{r}
#| eval: true
#| warning: false
#| label: fig-doctorgraphsidebyside
#| echo: fenced
#| fig-cap: "두 가지 그래프 변형"
#| fig-subcap: ["질병","의사 방문"]
#| layout-ncol: 2

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count") +
  theme_minimal()

DoctorVisits |>
  ggplot(aes(x = visits)) +
  geom_histogram(stat = "count") +
  theme_classic()
```

표를 상호 참조하는 데 비슷한 접근 방식을 사용할 수 있습니다. 예를 들어, `(@tbl-docvisittable)`은 (@tbl-docvisittable)을 생성합니다. 이 경우 Quarto가 표임을 알 수 있도록 레이블 시작 부분에 "tbl"을 지정합니다. 그리고 "tbl-cap:"으로 표에 대한 캡션을 지정합니다.\index{tables!cross-references}

```{r}
#| echo: fenced
#| label: tbl-docvisittable
#| tbl-cap: "의사 방문 횟수 분포"

DoctorVisits |>
  count(visits) |>
  tt() |>
  style_tt(j = 2, align = "r") |>
  setNames(c("Number of visits", "Occurrences"))
```

마지막으로 방정식도 상호 참조할 수 있습니다.\index{equations!cross-reference} 그러려면 참조할 태그(예: `{#eq-macroidentity}`)를 추가해야 합니다.

``` markdown
$$
Y = C + I + G + (X - M)
$$ {#eq-gdpidentity}
```

예를 들어, `@eq-gdpidentity`를 사용하여 @eq-gdpidentity를 생성합니다.

$$
Y = C + I + G + (X - M)
$$ {#eq-gdpidentity}

상호 참조를 사용할 때 레이블은 비교적 간단해야 합니다. 일반적으로 이름을 간단하지만 고유하게 유지하고 구두점을 피하고 문자와 하이픈만 사용하십시오. 밑줄은 오류를 유발할 수 있으므로 사용하지 마십시오.


## R 프로젝트 및 파일 구조

프로젝트\index{R!R Projects}는 소프트웨어 개발에서 널리 사용되며 특정 프로젝트와 관련된 모든 파일(데이터, 분석, 보고서 등)을 함께 유지하고 서로 관련시키기 위해 존재합니다. (소프트웨어 개발 의미에서의 "프로젝트" 사용은 프로젝트 관리 의미에서의 "프로젝트"와 구별됩니다.) R 프로젝트는 RStudio에서 만들 수 있습니다. "파일" $\rightarrow$ "새 프로젝트"를 클릭한 다음 "빈 프로젝트"를 선택하고 R 프로젝트 이름을 지정하고 저장할 위치를 결정합니다. 예를 들어, 산모 사망률에 초점을 맞춘 R 프로젝트는 "maternalmortality"라고 부를 수 있습니다. R 프로젝트를 사용하면 "다른 컴퓨터나 사용자 간에 그리고 시간이 지남에 따라 안정적이고 정중한 동작"이 가능합니다[@whattheyforgot]. 이는 해당 폴더의 컨텍스트를 더 넓은 존재에서 제거하기 때문입니다. 파일은 컴퓨터의 기본이 아니라 R 프로젝트의 기본과 관련하여 존재합니다.

프로젝트가 생성되면 해당 폴더에 확장자가 ".RProj"인 새 파일이 나타납니다. R 프로젝트, Quarto 문서 및 적절한 파일 구조가 있는 폴더의 예는 [여기](https://github.com/RohanAlexander/starter_folder)에서 확인할 수 있습니다. "코드" $\rightarrow$ "ZIP 다운로드"를 통해 다운로드할 수 있습니다.

R 프로젝트 사용의 주요 이점은 자체 포함된 방식으로 내부 파일을 참조할 수 있다는 것입니다. 즉, 다른 사람이 우리 작업을 재현하려고 할 때 모든 파일 참조와 구조를 변경할 필요가 없습니다. 모든 것이 ".Rproj" 파일과 관련하여 참조되기 때문입니다. 예를 들어, `"~/Documents/projects/book/data/"`와 같은 곳에서 CSV를 읽는 대신 `book/data/`에서 읽을 수 있습니다. 다른 사람이 `projects` 폴더를 가지고 있지 않을 수 있으므로 전자는 작동하지 않지만 후자는 작동합니다.

프로젝트 사용은 신뢰할 수 있는 작업에 필요한 최소한의 재현성 수준을 충족하는 데 필요합니다. `setwd()`와 같은 함수 및 컴퓨터별 파일 경로를 사용하면 작업이 특정 컴퓨터에 부적절하게 바인딩됩니다.

폴더를 설정하는 다양한 방법이 있습니다\index{folder structure}. 시작할 때 종종 유용한 @wilsongoodenough의 변형은 위에 링크된 예제 파일 구조에 나와 있습니다.

```text
example_project/
├── .gitignore
├── LICENSE.md
├── README.md
├── example_project.Rproj
├── data
│   ├── 00-simulated_data
│   │   ├── simulated_data.csv
│   ├── 01-raw_data
│   │   ├── raw_data.csv
│   ├── 02-analysis_data
│   │   ├── analysis_data.csv
│   │   └── ...
├── model
│   ├── first_model.rds
├── other
│   ├── datasheet
│   │   └── ...
│   ├── literature
│   │   └── ...
│   ├── llm_usage
│   │   └── ...
│   ├── sketches
│   │   └── ...
├── paper
│   ├── paper.pdf
│   ├── paper.qmd
│   ├── references.bib
│   └── ...
├── scripts
│   ├── 00-simulate_data.R
│   ├── 01-test_simulated_data.R
│   ├── 02-download_data.R
│   ├── 03-clean_data.R
│   ├── 04-test_analysis_data.R
│   ├── 05-eda.R
│   ├── 06-model_data.R
│   ├── 07-replication.R
│   └── ...
└── ...
```

여기에는 시뮬레이션된 데이터, 덮어쓰면 안 되는 편집되지 않은 데이터[@wilsongoodenough] 및 함께 모은 분석 데이터가 포함된 `data` 폴더가 있습니다. `model` 폴더에는 저장된 모델 추정치가 포함되어 있습니다. `other` 폴더에는 데이터시트, 문헌, LLM 사용량 및 스케치와 같은 측면이 포함되어 있으며 상황에 따라 유용합니다. `paper` 폴더에는 Quarto 문서와 BibTeX 파일이 포함되어 있습니다. 마지막으로 `scripts`에는 데이터를 시뮬레이션, 다운로드, 테스트 및 분석하는 코드가 포함되어 있습니다.

유용한 다른 측면으로는 프로젝트에 대한 개요 세부 정보를 지정하는 `README.md`와 LICENSE가 있습니다. README에 무엇을 넣어야 하는지에 대한 예는 [여기](https://social-science-data-editors.github.io/template_README/)에서 확인할 수 있습니다. 이 프로젝트 골격의 또 다른 유용한 변형은 @GoodResearchCode에서 제공합니다.



## 버전 관리

이 책에서는 Git과 GitHub\index{GitHub!reproducibility}\index{Git!reproducibility}의 조합을 통해 버전 관리\index{reproducibility!version control}를 구현합니다. 여기에는 다음과 같은 다양한 이유가 있습니다.

1. 코드와 데이터 공유를 용이하게 하여 작업의 재현성을 향상시킵니다.\index{reproducibility!GitHub}
2. 작업 공유를 용이하게 합니다.
3. 체계적인 접근 방식을 장려하여 워크플로를 개선합니다.\index{GitHub!workflow}\index{workflow!GitHub} 그리고
4. 팀 작업을 용이하게 합니다.\index{GitHub!teams}

Git은 흥미로운 역사를 가진 버전 관리 시스템입니다[@githistory]. 버전 관리를 시작하는 일반적인 방법은 하나의 파일에 대한 다양한 복사본을 갖는 것입니다. "first_go.R", "first_go-fixed.R", "first_go-fixed-with-mons-edits.R". 그러나 이것은 곧 번거로워집니다. 종종 날짜를 사용하게 됩니다. 예를 들어, "2022-01-01-analysis.R", "2022-01-02-analysis.R", "2022-01-03-analysis.R" 등입니다. 이것은 기록을 유지하지만, 변경이 이루어진 날짜를 기억하기 어렵기 때문에 다시 돌아가야 할 때 검색하기 어려울 수 있습니다. 어쨌든 정기적으로 작업하는 프로젝트에는 금방 다루기 어려워집니다.

대신 Git을 사용하여 파일의 한 버전만 갖도록 합니다. Git은 해당 파일의 변경 사항 기록과 특정 시점의 해당 파일 스냅샷을 유지합니다. Git이 해당 스냅샷을 찍는 시기를 결정합니다. 또한 이 스냅샷과 마지막 스냅샷 사이에 변경된 내용을 설명하는 메시지를 추가합니다. 이렇게 하면 파일의 버전이 하나만 있고 기록을 더 쉽게 검색할 수 있습니다.

한 가지 복잡한 점은 Git이 소프트웨어 개발자 팀을 위해 설계되었다는 것입니다. 따라서 작동하지만 개발자가 아닌 사람에게는 약간 어색할 수 있습니다. 그럼에도 불구하고 Git은 데이터 과학에 유용하게 적용되었으며, 유일한 협력자가 미래의 자신일지라도 마찬가지입니다[@Bryan2018].\index{data science!Git}\index{Git!data science}

GitHub, GitLab 및 기타 다양한 회사에서는 Git을 기반으로 하는 사용하기 쉬운 서비스를 제공합니다. 절충안이 있지만 여기서는 GitHub가 지배적인 플랫폼이므로 소개합니다[@eghbal2020working, p. 21]. Git과 GitHub는 Posit Cloud에 내장되어 있어 로컬 설치에 문제가 있는 경우 좋은 옵션을 제공합니다. Git의 초기 어려운 측면 중 하나는 용어입니다.\index{Git!terminology} 폴더는 "repo"라고 합니다. 스냅샷을 만드는 것을 "커밋"이라고 합니다. 결국 익숙해지지만 처음에는 혼란스러움을 느끼는 것이 정상입니다. @happygit은 Git과 GitHub를 설정하고 사용하는 데 특히 유용합니다.



### Git

먼저 Git\index{Git!set up}이 설치되어 있는지 확인해야 합니다. RStudio를 열고 터미널로 이동하여 다음을 입력한 다음 Enter/Return을 누릅니다.

```{bash}
#| eval: false
#| echo: true

git --version
```

버전 번호가 표시되면 완료된 것입니다(@fig-gitone).

::: {#fig-grits layout-ncol=1}

![RStudio에서 터미널을 사용하여 Git이 설치되어 있는지 확인](figures/03-git-setup-01.png){#fig-gitone}

![RStudio에서 Git에 사용자 이름과 이메일 주소 추가](figures/03-git-setup-02.png){#fig-gitone-setup}

Git 설정과 관련된 단계 개요
:::


Git은 Posit Cloud\index{Posit Cloud!Git}\index{Git!Posit Cloud}에 사전 설치되어 있으며 Mac에는 사전 설치되어 있어야 하며 Windows에도 사전 설치되어 있을 수 있습니다. 응답으로 버전 번호가 표시되지 않으면 설치해야 합니다. 그렇게 하려면 @happygit [5장]의 운영 체제별 지침을 따라야 합니다.

Git이 설치된 후 사용자 이름과 이메일을 알려줘야 합니다. Git은 스냅샷을 찍을 때마다 또는 Git의 용어로 커밋을 할 때마다 이 정보를 추가하기 때문에 이 작업을 수행해야 합니다.

다시 터미널 내에서 다음을 입력하고 세부 정보를 사용자 정보로 바꾼 다음 각 줄 다음에 "enter/return"을 누릅니다.

```{bash}
#| eval: false
#| echo: true

git config --global user.name "로한 알렉산더"
git config --global user.email "rohan.alexander@utoronto.ca"
git config --global --list
```

이 설정이 제대로 완료되면 "user.name"과 "user.email"에 입력한 값이 마지막 줄 다음에 반환됩니다(@fig-gitone-setup).

이러한 세부 정보(사용자 이름 및 이메일 주소)는 공개됩니다. 필요한 경우 이메일 주소를 숨기는 다양한 방법이 있으며 GitHub에서 이에 대한 지침을 제공합니다. @happygit [7장]에서는 이 단계에 대한 자세한 지침과 문제 해결 가이드를 제공합니다.


### GitHub

이제 Git이 설정되었으므로 GitHub\index{GitHub}를 설정해야 합니다. @sec-fire-hose에서 GitHub 계정을 만들었으며 여기서 다시 사용합니다. `github.com`에 로그인한 후 먼저 새 폴더를 만들어야 하는데, Git에서는 이를 "repo"라고 합니다. 오른쪽 상단에서 "+"를 찾은 다음 "새 리포지토리"를 선택합니다(@fig-githubtwo).

::: {#fig-gritshub layout-nrow=3}

![새 리포지토리 만들기 프로세스 시작](figures/github_2.png){#fig-githubtwo}

![새 리포지토리의 URL 복사](figures/github_4.png){#fig-githubfour}

![Posit Cloud에 프로젝트 추가](figures/03-github-new-project.png){#fig-githubnewproject}

![PAT 만들기](figures/04-githubpat.png){#fig-githubpat}

![커밋할 파일 추가](figures/03-github-add.png){#fig-githubadd}

![커밋 만들기](figures/03-github-commit.png){#fig-githubcommit}

GitHub 설정과 관련된 단계 개요
:::

이 시점에서 리포지토리에 적절한 이름을 추가할 수 있습니다. 나중에 언제든지 삭제할 수 있으므로 지금은 "공개"로 두십시오. 그리고 "이 리포지토리를 README로 초기화" 확인란을 선택합니다. "Add .gitignore"를 R로 변경합니다. 그런 다음 "리포지토리 만들기"를 클릭합니다.

이렇게 하면 상당히 비어 있는 화면으로 이동하지만 필요한 세부 정보(URL)는 녹색 "복제 또는 다운로드" 버튼에 있으며 클립보드를 클릭하여 복사할 수 있습니다(@fig-githubfour).

이제 RStudio\index{R!RStudio}로 돌아가서 Posit Cloud\index{Posit Cloud}에서 "Git 리포지토리에서 새 프로젝트"를 사용하여 새 프로젝트를 만듭니다. 방금 복사한 URL을 묻는 메시지가 표시됩니다(@fig-githubnewproject). 로컬 컴퓨터를 사용하는 경우 이 단계는 메뉴를 통해 수행됩니다. "파일" $\rightarrow$ "새 프로젝트..." $\rightarrow$ "버전 관리" $\rightarrow$ "Git"을 선택한 다음 URL을 붙여넣고 폴더에 의미 있는 이름을 지정하고 "새 세션에서 열기"를 선택한 다음 "프로젝트 만들기"를 클릭합니다.

이 시점에서 사용할 수 있는 새 폴더가 만들어졌습니다. GitHub로 다시 푸시하려면 RStudio 작업 공간을 GitHub\index{GitHub} 계정과 연결하기 위해 개인 액세스 토큰(PAT)을 사용해야 합니다. 이를 위해 `usethis`와 `gitcreds`를 사용합니다. 이들은 각각 반복적인 작업을 자동화하는 패키지와 GitHub로 인증하는 패키지입니다. PAT를 만들려면 브라우저에서 GitHub에 로그인한 후 `usethis`를 설치하고 로드한 다음 R 세션에서 `create_github_token()`을 실행합니다. GitHub가 브라우저에서 다양한 옵션이 채워진 상태로 열립니다(@fig-githubpat). "참고"를 바꿔 PAT에 정보성 이름을 지정하는 것이 유용할 수 있습니다(예: "RStudio용 PAT"). 그런 다음 "토큰 생성"을 클릭합니다.

이 토큰을 복사할 기회는 한 번뿐이며 실수하면 새 토큰을 생성해야 합니다. PAT\index{Personal Access Token!GitHub}를 R 스크립트나 Quarto 문서에 포함하지 마십시오. 대신 `gitcreds`를 설치하고 로드한 후 `gitcreds_set()`을 실행하면 콘솔에 PAT를 추가하라는 메시지가 표시됩니다.

현재 작업 중인 프로젝트에 GitHub\index{GitHub}를 사용하려면 다음 절차를 따릅니다.

1. 가장 먼저 해야 할 일은 거의 항상 "풀"을 사용하여 변경 사항을 가져오는 것입니다. 이렇게 하려면 RStudio에서 Git 창을 열고 파란색 아래쪽 화살표를 클릭합니다.\index{Git!RStudio} 이렇게 하면 GitHub에 있는 폴더의 변경 사항을 자신의 폴더 버전으로 가져옵니다.
2. 그런 다음 폴더 복사본을 변경할 수 있습니다. 예를 들어 README를 업데이트한 다음 평소와 같이 저장할 수 있습니다.
3. 이 작업이 완료되면 추가, 커밋 및 푸시해야 합니다. RStudio의 Git 창에서 추가할 파일을 선택합니다. 이렇게 하면 스테이징 영역에 추가됩니다. 그런 다음 "커밋"을 클릭합니다(@fig-githubadd). 새 창이 열립니다. 변경 사항에 대한 정보성 메시지를 추가한 다음 해당 새 창에서 "커밋"을 클릭합니다(@fig-githubcommit). 마지막으로 "푸시"를 클릭하여 변경 사항을 GitHub로 보냅니다.

Git과 GitHub에 관해서는 몇 가지 일반적인 문제점이 있습니다. 버전 관리를 처음 사용하는 경우 특히 정기적으로 커밋하고 푸시하는 것이 좋습니다. 이렇게 하면 필요한 경우 다시 돌아올 수 있는 스냅샷 수가 늘어납니다. 모든 커밋에는 정보성 커밋 메시지가 있어야 합니다. 버전 관리를 처음 사용하는 경우 좋은 커밋 메시지에 대한 기대는 변경 사항에 대한 간략한 요약, 빈 줄, 변경 사항이 무엇인지, 왜 변경하는지를 포함한 변경 사항에 대한 설명입니다. 예를 들어, 커밋이 논문에 그래프를 추가하는 경우 커밋 메시지는 다음과 같을 수 있습니다.

```{verbatim}
그래프 추가

데이터 섹션에 실업률 및 인플레이션 그래프 추가됨.
```

전반적인 품질과 커밋 행동 사이에는 어떤 관계가 있다는 증거가 있습니다[@sprint2019mining]. 경험이 많아질수록 커밋 메시지가 프로젝트의 일종의 일지 역할을 하는 것이 이상적입니다. 그러나 가장 중요한 것은 정기적으로 커밋하는 것입니다.

Git과 GitHub는 데이터 과학자가 아닌 소프트웨어 개발자를 위해 설계되었습니다. GitHub는 고려할 파일 크기를 100MB로 제한하며, 50MB만 되어도 경고가 표시될 수 있습니다.\index{GitHub!file size} 데이터 과학 프로젝트에는 이보다 큰 데이터셋이 정기적으로 포함됩니다. @sec-store-and-share에서는 프로젝트가 완료되었을 때 특히 유용할 수 있는 데이터 저장소 사용에 대해 논의하지만, 프로젝트를 적극적으로 작업할 때는 적어도 Git과 GitHub에 관한 한 대용량 데이터 파일을 무시하는 것이 유용할 수 있습니다. Git을 사용하여 추적하고 싶지 않은 모든 파일을 나열하는 ".gitignore" 파일을 사용하여 이 작업을 수행합니다. [예제 폴더](https://github.com/RohanAlexander/starter_folder)에는 ".gitignore" 파일이 포함되어 있습니다. 그리고 `usethis`의 `git_vaccinate()`를 실행하면 프로젝트별로 수행하는 것을 잊어버릴 경우를 대비하여 다양한 파일을 전역 ".gitignore" 파일에 추가하므로 도움이 될 수 있습니다. Mac 사용자는 이로 인해 ".DS_Store" 파일이 무시되므로 유용하다는 것을 알게 될 것입니다.

RStudio의 Git 창을 사용하여 터미널을 사용할 필요가 없었지만 GitHub로 이동하여 새 프로젝트를 설정할 필요는 없었습니다. Git과 GitHub를 설정했으므로 `usethis`를 사용하여 워크플로의 이 측면을 더욱 개선할 수 있습니다.

먼저 `usethis`의 `git_sitrep()`를 사용하여 Git이 설정되어 있는지 확인합니다. 사용자 이름과 이메일에 대한 정보가 인쇄되어야 합니다. 필요한 경우 `use_git_config()`를 사용하여 이러한 세부 정보를 업데이트할 수 있습니다.

```{r}
#| eval: false
#| include: true

use_git_config(
  user.name = "로한 알렉산더",
  user.email = "rohan.alexander@utoronto.ca"
)
```

GitHub에서 새 프로젝트를 시작한 다음 로컬에 추가하는 대신 이제 `use_git()`를 사용하여 초기화하고 파일을 커밋할 수 있습니다. 커밋한 후에는 `use_github()`를 사용하여 GitHub로 푸시하여 GitHub에도 폴더를 만들 수 있습니다.

Git과 GitHub에 겁을 먹는 것은 정상입니다. 많은 데이터 과학자들은 사용 방법에 대해 약간만 알고 있으며 괜찮습니다. 필요한 경우 최근 스냅샷을 갖도록 정기적으로 푸시하십시오.

### Git 충돌

*파우스트 박사*는 크리스토퍼 말로의 16세기 희곡입니다. 흥미롭게도 두 가지 버전이 있으며 말로가 실제로 어떤 버전을 "그" 버전으로 의도했는지 아무도 모릅니다. 정확히 무엇을 세느냐에 따라 @faustus1604에는 약 2,048줄이 있고 @faustus1616에는 약 2,852줄이 있습니다. 줄 안에도 변경 사항이 있습니다(@fig-githubconflict). 저자는 오래전에 사망했으므로 인류는 단순히 두 가지 버전이 있다는 이상한 상황에 처해 있습니다. 말로에게 Git이 있었다면 이런 일은 일어나지 않았을 것입니다!

::: {#fig-githubconflict layout-nrow=1}

![1604년 버전의 첫 몇 줄](figures/03-faustus1604.png){#fig-githubconflictone}

![1616년 버전의 첫 몇 줄](figures/03-faustus1616.png){#fig-githubconflicttwo}

파우스트 박사의 1604년 버전과 1616년 버전 간의 차이점 표시
:::

Git과 GitHub를 사용할 때 때때로 버전을 체크인합니다. 그러나 동일한 리포지토리에서 작업하는 두 사람이 동일한 줄에 변경 사항을 적용하는 코드를 체크인하려고 하면 어떻게 될까요? Git은 병합 충돌을 설정하고 충돌을 해결하는 것은 충돌을 표면화한 사람, 즉 두 번째 커밋을 한 사람에게 달려 있습니다.

Git은 파일에 충돌하는 줄을 모두 표시하고 시작 부분에 `<<<<<<< HEAD` 식별 마커를 추가하고, 충돌하는 변경 사항을 구분하기 위해 `=======`를 추가하고, 끝과 충돌을 일으키는 분기를 표시하기 위해 `>>>>>>> new_branch`를 추가하여 충돌하는 줄을 식별합니다.

```{bash}
#| eval: false
#| echo: true

<<<<<<< HEAD
일부 내용
=======
일부 충돌하는 내용
>>>>>>> new_branch
```

충돌을 해결하려는 사람의 임무는 어떤 내용을 유지할지 선택하는 것입니다. 파일을 편집하고 저장한 다음 일반적인 방법으로 추가하고 커밋합니다.



## 실제 R 사용

### 오류 처리 {#sec-dealingwitherrors}

> 프로그래밍을 할 때 결국 코드가 깨질 것입니다. 결국이라고 말하지만, 아마 하루에 10번이나 20번 정도일 것입니다.
>
> @sharlatalks

R이나 다른 프로그래밍 언어를 사용하는 모든 사람은 어느 시점에서 문제를 발견합니다. 이것은 정상입니다. 프로그래밍은 어렵습니다. 어느 시점에서 코드가 실행되지 않거나 오류가 발생합니다.\index{R!errors} 이것은 모든 사람에게 발생합니다. 좌절감을 느끼는 것은 일반적이지만 앞으로 나아가기 위해 문제 해결 전략을 개발합니다.\index{help!strategies}

1. 오류 메시지가 표시되면 때때로 유용할 수 있습니다. 유용한 내용이 있는지 주의 깊게 읽어보십시오.
2. 오류 메시지를 검색해 보십시오.\index{Google!getting help} 검색 결과의 적절성을 높이기 위해 검색어에 "tidyverse" 또는 "in R"을 포함하는 것이 유용할 수 있습니다. 때때로 Stack Overflow 결과가 유용할 수 있습니다.
3. 함수 앞에 "?"를 붙여 함수의 도움말 파일을 살펴보십시오(예: `?pivot_wider()`). 일반적인 문제는 약간 잘못된 인수 이름이나 형식(예: 객체 이름 대신 실수로 문자열을 포함하는 것)을 사용하는 것입니다.
4. 오류가 발생하는 위치를 살펴보고 오류가 해결될 때까지 코드를 제거하거나 주석 처리한 다음 코드를 천천히 다시 추가하십시오.
5. `class()`를 사용하여 객체의 클래스를 확인하십시오(예: `class(data_set$data_column)`). 예상되는 것인지 확인하십시오.\index{help!check the class}
6. R을 다시 시작하십시오: "세션" $\rightarrow$ "R 다시 시작 및 출력 지우기". 그런 다음 모든 것을 다시 로드하십시오.
7. 컴퓨터를 다시 시작하십시오.
8. 오류 대신 수행하려는 작업을 검색하고 검색 결과의 적절성을 높이기 위해 검색어에 "tidyverse" 또는 "in R"을 포함해야 합니다. 예를 들어, "ggplot을 사용하여 R에서 그래프의 PDF 저장"입니다. 때때로 도움이 될 관련 블로그 게시물이나 Stack Overflow 답변이 있습니다.
9. 문제를 격리하고 다른 사람이 도울 수 있도록 작고 독립적인 재현 가능한 예제 "reprex"를 만드십시오.\index{reprex}\index{help!reproducible example}
10. Quarto 문서에서 작업하는 경우 청크 옵션에 레이블을 포함하여 실수가 발생하는 위치를 더 쉽게 찾을 수 있도록 하십시오.

더 일반적으로, 항상 가능한 것은 아니지만 휴식을 취하고 다음 날 다시 돌아오는 것이 거의 항상 도움이 됩니다.


### 재현 가능한 예제  {#sec-omgpleasemakeareprexplease}

> 아무도 당신에게 조언하거나 도울 수 없습니다. 아무도 없습니다. 당신이 해야 할 일은 단 한 가지뿐입니다. 자신 속으로 들어가십시오.
>
> @rilke

도움을 요청하는 것은 다른 기술과 마찬가지로 하나의 기술입니다.\index{help!reproducible example} 연습을 통해 더 잘하게 됩니다. "이것은 작동하지 않습니다", "모든 것을 시도했습니다", "당신의 코드는 작동하지 않습니다" 또는 "오류 메시지가 여기 있습니다. 어떻게 해야 합니까?"라고 말하지 않도록 노력하는 것이 중요합니다. 일반적으로 가능한 문제가 너무 많기 때문에 이러한 의견을 바탕으로 도움을 줄 수 없습니다. 다른 사람이 당신을 도울 수 있도록 쉽게 만들어야 합니다. 여기에는 몇 가지 단계가 포함됩니다.\index{help!asking for}

1. 데이터, 코드의 작고 독립적인 예제를 제공하고 무엇이 잘못되었는지 자세히 설명하십시오.
2. 지금까지 시도한 내용을 문서화하고, 살펴본 Stack Overflow 및 Posit 포럼 게시물과 원하는 내용이 아닌 이유를 포함하십시오.
3. 원하는 결과에 대해 명확하게 설명하십시오.

최소한의 재현 가능한 예제(REPRoducible EXample), 즉 "reprex"를 만드는 것부터 시작하십시오.\index{reprex} 이것은 오류를 재현하는 데 필요한 코드를 포함하지만 필요한 것만 포함합니다. 즉, 코드는 오류를 재현하지만 더 작고 간단한 버전일 가능성이 높습니다.

때로는 이 과정에서 문제를 해결할 수 있습니다. 그렇지 않은 경우 다른 사람이 도움을 줄 수 있는 기회를 제공합니다. 이전에 아무도 다루지 않은 문제를 겪고 있을 가능성은 거의 없습니다. 주요 어려움은 자신이 하고 싶은 일과 일어나고 있는 일을 다른 사람이 모두 인식할 수 있는 방식으로 전달하려고 노력하는 것일 가능성이 더 큽니다. 끈기를 키우는 것이 중요합니다.

재현 가능한 예제를 개발하려면 `reprex`가 특히 유용합니다. 설치 후 다음을 수행합니다.

1. `reprex` 패키지를 로드합니다: `library(reprex)`.
2. 문제가 있는 코드를 강조 표시하고 복사합니다.
3. 콘솔에서 `reprex()`를 실행합니다.

코드가 독립적이면 뷰어에서 미리보기가 표시됩니다. 그렇지 않으면 오류가 발생하며 코드를 독립적으로 만들도록 다시 작성해야 합니다.

오류를 재현하기 위해 데이터가 필요한 경우 R에 내장된 데이터를 사용해야 합니다. R에 내장된 데이터셋은 많이 있으며 `library(help = "datasets")`를 사용하여 볼 수 있습니다. 그러나 가능하면 `mtcars` 또는 `faithful`과 같은 일반적인 옵션을 사용해야 합니다. @sec-fire-hose에서 소개된 GitHub Gist와 reprex를 결합하면 누군가가 당신을 도울 가능성이 높아집니다.






### 정신 자세

> 어떤 IDE에서 개발하든 어떤 도구를 사용하여 작업을 하든 당신은 실제적이고 유효하며 *유능한* 사용자이자 프로그래머입니다.
>
> 문을 부수자, 모두를 위한 충분한 공간이 있다.
>
> 샤를라 겔판드, 2020년 3월 10일.

코드를 작성하면 어떻게 하든, 무엇을 위해 사용하든, 누구든 프로그래머입니다.\index{code!traits} 그러나 훌륭한 프로그래머들이 공통적으로 가지고 있는 몇 가지 특징이 있습니다.

- **집중:** 종종 "R 배우기"와 같은 목표는 실제 끝점이 없기 때문에 문제가 되는 경향이 있습니다. "ggplot2로 2022년 호주 선거에 대한 히스토그램 만들기"와 같이 더 작고 구체적인 목표를 갖는 것이 더 효율적인 경향이 있습니다. 이것은 몇 시간 안에 집중하고 달성할 수 있는 것입니다. "R을 배우고 싶다"와 같이 더 모호한 목표의 문제는 곁길로 새기 쉽고 도움을 받기가 더 어렵다는 것입니다. 이것은 의욕을 꺾고 사람들이 너무 일찍 그만두게 만들 수 있습니다.
- **호기심:** "한번 해보는 것"은 거의 항상 유용합니다. 즉, 확실하지 않으면 그냥 시도해 보십시오. 일반적으로 최악의 경우는 시간을 낭비하는 것입니다. 돌이킬 수 없을 정도로 무언가를 망가뜨리는 경우는 거의 없습니다. 예를 들어, 데이터프레임 대신 벡터를 `ggplot()`에 전달하면 어떻게 되는지 알고 싶다면 시도해 보십시오.
- **실용적:** 동시에 합리적인 범위 내에서 유지하고 매번 작은 변경 사항을 하나씩 적용하는 것이 유용할 수 있습니다. 예를 들어, 일부 회귀 분석을 실행하고 싶고 `lm()` 대신 `rstanarm`을 사용할 가능성에 대해 궁금하다고 가정해 보겠습니다. 실용적인 진행 방법은 처음에 `rstanarm`의 한 가지 측면을 사용한 다음 다음에 다른 변경 사항을 적용하는 것입니다.
- **끈기:** 다시 말하지만, 이것은 균형 잡힌 행동입니다. 모든 프로젝트에서 예상치 못한 문제와 이슈가 발생합니다. 한편으로는 이러한 문제에도 불구하고 인내하는 것이 좋은 경향입니다. 그러나 다른 한편으로는 돌파구가 가능해 보이지 않으면 무언가를 포기할 준비가 되어 있어야 합니다. 멘토는 무엇이 합리적인지 더 잘 판단하는 경향이 있으므로 유용할 수 있습니다.
- **계획적:** 무엇을 할 것인지 과도하게 계획하는 것은 거의 항상 유용합니다. 예를 들어, 일부 데이터의 히스토그램을 만들고 싶을 수 있습니다. 필요한 단계를 계획하고 각 단계가 어떻게 구현될 수 있는지 스케치해야 합니다. 예를 들어, 첫 번째 단계는 데이터를 가져오는 것입니다. 어떤 패키지가 유용할 수 있습니까? 데이터는 어디에 있을 수 있습니까? 데이터가 거기에 없으면 백업 계획은 무엇입니까?
- **완벽보다 완료:** 우리 모두는 다양한 완벽주의적 경향을 가지고 있지만, 어느 정도까지는 처음에는 그것들을 끄려고 노력하는 것이 유용할 수 있습니다. 처음에는 작동하는 코드를 작성하는 것에만 신경 쓰십시오. 언제든지 돌아와서 측면을 개선할 수 있습니다. 그러나 실제로 출시하는 것이 중요합니다. 작업을 완료하는 보기 흉한 코드가 결코 끝나지 않는 아름다운 코드보다 낫습니다.



### 코드 주석 및 스타일

코드는 주석 처리되어야 합니다.\index{code!comments} 주석은 특정 코드가 작성된 이유와 일반적인 대안이 선택되지 않은 이유에 덜 초점을 맞춰야 합니다. 실제로 코드를 작성하기 전에 주석을 작성하여 무엇을 하고 싶은지, 왜 하고 싶은지 설명한 다음 코드를 작성하는 것이 좋습니다[@refactoringbook, p. 59].

특히 R에서는 코드를 작성하는 방법이 하나만 있는 것은 아닙니다. 그러나 혼자 작업하는 경우에도 더 쉽게 작업할 수 있도록 하는 몇 가지 일반적인 지침이 있습니다. 대부분의 프로젝트는 시간이 지남에 따라 발전하며 코드 주석의 한 가지 목적은 미래의 자신이 수행한 작업과 특정 결정이 내려진 이유를 추적할 수 있도록 하는 것입니다[@bowers2016improve].

R 스크립트의 주석은 # 기호를 포함하여 추가할 수 있습니다. (#의 동작은 Quarto 문서의 R 청크 내부 줄에서는 주석으로 작동하지만 R 청크 외부 줄에서는 제목 수준을 설정하는 것과 다릅니다.) 줄 시작 부분에 주석을 달 필요는 없으며 중간에 달 수도 있습니다. 일반적으로 코드의 모든 측면이 무엇을 하는지 주석 처리할 필요는 없지만 명확하지 않은 부분은 주석 처리해야 합니다. 예를 들어, 일부 값을 읽어오면 어디서 가져오는지 주석 처리하고 싶을 수 있습니다.

왜 무언가를 하고 있는지 주석을 달아야 합니다[@tidyversestyleguide]. 무엇을 달성하려고 합니까? 이상한 것을 설명하기 위해 주석을 달아야 합니다. 예를 들어 특정 행(예: 27행)을 제거하는 경우 해당 행을 제거하는 이유는 무엇입니까? 순간에는 명백해 보일 수 있지만 미래의 당신은 기억하지 못할 것입니다.

코드를 섹션으로 나누어야 합니다. 예를 들어, 작업 공간 설정, 데이터셋 읽기, 데이터셋 조작 및 정리, 데이터셋 분석, 마지막으로 표와 그림 생성입니다. 각 섹션은 무슨 일이 일어나고 있는지 설명하는 주석으로 구분되어야 하며 길이에 따라 때로는 별도의 파일로 구분되어야 합니다.

또한 각 파일 상단에는 파일의 목적, 전제 조건 또는 종속성, 날짜, 작성자 및 연락처 정보, 마지막으로 위험 신호나 할 일과 같은 기본 정보를 기록하는 것이 중요합니다.

R 스크립트에는 머리글과 명확한 섹션 구분이 있어야 합니다.

```
#### 머리말 ####
# 목적: 이 스크립트가 하는 일에 대한 간략한 문장
# 저자: 귀하의 이름
# 날짜: 작성일
# 연락처: 이메일 추가
# 라이선스: 코드가 어떻게 사용될 수 있는지 생각해 보십시오.
# 전제 조건:
# - 일부 데이터나 다른 스크립트가 실행되어야 할 수도 있습니까?


#### 작업 공간 설정 ####
# install.packages 줄을 유지하지 마십시오. 필요한 경우 주석 처리하십시오.
# 패키지 로드
library(tidyverse)

# 편집되지 않은 데이터를 읽어옵니다.
raw_data <- read_csv("inputs/data/unedited_data.csv")


#### 다음 섹션 ####
...

```

마지막으로 사용자가 코드를 주석 처리하고 주석 처리를 해제하거나 디렉터리 지정과 같은 다른 수동 단계를 수행하여 코드가 작동하도록 하는 데 의존하지 마십시오. 이렇게 하면 자동화된 코드 확인 및 테스트를 사용할 수 없습니다.

이 모든 작업에는 시간이 걸립니다. 대략적인 경험 법칙으로 코드를 작성하는 데 걸린 시간만큼 코드를 주석 처리하고 개선하는 데 시간을 할애해야 합니다. 깔끔하게 주석 처리된 코드의 예로는 @AhadyDolatsara2021 및 @burton2021reconsidering이 있습니다.



### 테스트

테스트\index{testing}는 코드 전체에 걸쳐 작성되어야 하며, 마지막에 한꺼번에 작성하는 것이 아니라 진행하면서 작성해야 합니다. 이렇게 하면 속도가 느려집니다. 그러나 생각하고 실수를 수정하는 데 도움이 되어 코드가 더 좋아지고 전반적인 생산성이 향상됩니다. 테스트가 없는 코드는 의심스럽게 봐야 합니다. R 패키지의 테스트 관행에는 개선의 여지가 있으며[@Vidoni2021], 더 일반적으로 R 코드에 대해서는 말할 것도 없습니다.

다른 사람, 그리고 이상적으로는 자동화된 프로세스가 코드에서 테스트를 실행해야 할 필요성은 우리가 재현성을 강조하는 한 가지 이유입니다. 또한 파일 경로를 하드코딩하지 않고 프로젝트를 사용하고 파일 이름에 공백을 두지 않는 것과 같은 작은 측면을 강조하는 이유이기도 합니다.\index{reproducibility}

완전하고 일반적인 테스트 모음을 정의하기는 어렵지만 광범위하게 다음을 테스트하려고 합니다.

1) 경계 조건,
2) 클래스,
3) 누락된 데이터,
4) 관찰 및 변수의 수,
5) 중복, 그리고
6) 회귀 결과.

이 모든 작업을 처음에 시뮬레이션된 데이터에 대해 수행한 다음 실제 데이터로 이동합니다. 이는 아폴로 프로그램 중 테스트의 진화를 반영합니다. 처음에는 요구 사항에 대한 기대를 기반으로 테스트가 수행되었으며, 이러한 테스트는 나중에 실제 발사 측정을 고려하여 업데이트되었습니다[@testingforsuccess, p. 21]. 무한한 수의 테스트를 작성할 수 있지만 생각 없는 많은 테스트보다 소수의 고품질 테스트가 더 좋습니다.

테스트 유형 중 하나는 "어설션"입니다.\index{testing!assertion} 어설션은 무언가가 참인지 확인하고 그렇지 않으면 코드 실행을 중지하기 위해 코드 전체에 작성됩니다[@researchsoftware, p. 272]. 예를 들어, 변수가 숫자여야 한다고 어설션할 수 있습니다. 이 어설션에 대해 테스트되었을 때 문자로 판명되면 테스트가 실패하고 스크립트 실행이 중지됩니다. 데이터 과학의 어설션 테스트는 일반적으로 데이터 정리 및 준비 스크립트에서 사용됩니다. 이에 대해서는 @sec-clean-and-prepare에서 더 자세히 설명합니다. 단위 테스트는 코드의 완전한 측면을 확인합니다[@researchsoftware, p. 274].\index{testing!unit tests} 모델링을 고려할 때 @sec-its-just-a-linear-model에서 더 자세히 고려할 것입니다.



## 효율성

일반적으로\index{efficiency!code} 이 책에서는 무언가를 완료하는 데만 관심을 두고 있으며 앞으로도 그럴 것입니다. 반드시 최선의 방법이나 가장 효율적인 방법으로 완료하는 것은 아닙니다. 왜냐하면 대부분의 경우 그것에 대해 걱정하는 것은 시간 낭비이기 때문입니다. 대부분의 경우 클라우드에 밀어 넣고 합리적인 시간 동안 실행되도록 한 다음 그 시간을 파이프라인의 다른 측면을 걱정하는 데 사용하는 것이 좋습니다. 그러나 그것은 결국 실행 불가능해집니다. 어느 시점에서, 그리고 이것은 상황에 따라 다르지만, 효율성이 중요해집니다. 결국 보기 흉하거나 느린 코드와 특정 작업 방식에 대한 독단적인 주장은 영향을 미칩니다. 그리고 그 시점에서 효율성을 보장하기 위해 새로운 접근 방식에 개방적이어야 합니다. 명백한 성능 향상을 위한 가장 일반적인 영역은 거의 없습니다. 대신 측정, 평가 및 사고 능력을 개발하는 것이 중요합니다.

코드 효율성을 높이는 가장 좋은 방법 중 하나는 다른 사람이 검토할 수 있도록 준비하는 것입니다.\index{Peer review}\index{efficiency!by sharing} 시간을 최대한 활용하려면 코드를 읽기 쉽게 만드는 것이 중요합니다. 따라서 "코드 린팅"과 "스타일링"부터 시작합니다. 이것은 코드를 직접적으로 빠르게 만들지는 않지만 다른 사람이 코드를 보거나 잠시 쉬었다가 다시 볼 때 더 효율적으로 만듭니다. 이를 통해 공식적인 코드 검토 및 리팩토링이 가능해지며, 이는 코드가 하는 일은 변경하지 않고 더 좋게 만들기 위해 코드를 다시 작성하는 것입니다(동일한 작업을 하지만 다른 방식으로 수행합니다). 그런 다음 실행 시간 측정으로 전환하고 컴퓨터가 동시에 여러 프로세스에 대한 코드를 실행하도록 허용하는 병렬 처리를 도입합니다.


### 코드 환경 공유

::: {.content-visible when-format="pdf"}
코드 공유의 필요성에 대해 자세히 논의했으며 GitHub를 사용하는 접근 방식을 제시했습니다.\index{reproducibility}\index{efficiency!reproducibility} 그리고 @sec-store-and-share에서는 데이터 공유에 대해 논의할 것입니다. 그러나 다른 사람이 우리 코드를 실행할 수 있도록 하는 또 다른 요구 사항이 있습니다. @sec-fire-hose에서는 R 자체와 R 패키지가 새로운 기능이 개발되고 오류가 수정되며 기타 일반적인 개선이 이루어짐에 따라 때때로 업데이트되는 방식에 대해 논의했습니다. ["R 필수 사항" 온라인 부록](https://tellingstorieswithdata.com/20-r_essentials.html)에서는 `tidyverse`의 한 가지 장점이 기본 R보다 더 구체적이기 때문에 더 빠르게 업데이트될 수 있다는 점을 설명합니다. 그러나 이는 우리가 사용하는 모든 코드와 데이터를 공유하더라도 사용 가능해진 소프트웨어 버전으로 인해 오류가 발생할 수 있음을 의미할 수 있습니다.
:::

::: {.content-visible unless-format="pdf"}
코드 공유의 필요성에 대해 자세히 논의했으며 GitHub를 사용하는 접근 방식을 제시했습니다.\index{reproducibility}\index{efficiency!reproducibility} 그리고 @sec-store-and-share에서는 데이터 공유에 대해 논의할 것입니다. 그러나 다른 사람이 우리 코드를 실행할 수 있도록 하는 또 다른 요구 사항이 있습니다. @sec-fire-hose에서는 R 자체와 R 패키지가 새로운 기능이 개발되고 오류가 수정되며 기타 일반적인 개선이 이루어짐에 따라 때때로 업데이트되는 방식에 대해 논의했습니다. [온라인 부록 -@sec-r-essentials]에서는 `tidyverse`의 한 가지 장점이 기본 R보다 더 구체적이기 때문에 더 빠르게 업데이트될 수 있다는 점을 설명합니다. 그러나 이는 우리가 사용하는 모든 코드와 데이터를 공유하더라도 사용 가능해진 소프트웨어 버전으로 인해 오류가 발생할 수 있음을 의미할 수 있습니다.
:::

이에 대한 해결책은 사용된 환경을 자세히 설명하는 것입니다.\index{reproducibility} 이를 수행하는 방법은 여러 가지가 있으며 복잡성을 더할 수 있습니다. 우리는 사용된 R 및 R 패키지 버전을 문서화하고 다른 사람이 해당 정확한 버전을 더 쉽게 설치할 수 있도록 하는 데만 집중합니다. 기본적으로 재현성에 도움이 되기 때문에 사용한 설정을 격리하는 것입니다[@perkel2023]. `R`에서는 `renv`를 사용하여 이 작업을 수행할 수 있습니다.

`renv`가 설치되고 로드되면 `init()`를 사용하여 필요한 인프라 설정을 가져옵니다.\index{efficiency!reproducibility} 사용된 패키지와 버전을 기록할 파일을 만들 것입니다. 그런 다음 `snapshot()`을 사용하여 실제로 사용 중인 것을 문서화합니다. 이렇게 하면 정보를 기록하는 "잠금 파일"이 만들어집니다.

R 프로젝트에서 사용 중인 패키지를 확인하려면 `dependencies()`를 사용할 수 있습니다. [예제 폴더](https://github.com/RohanAlexander/starter_folder)에 대해 이 작업을 수행하면 `rmarkdown`, `bookdown`, `knitr`, `rmarkdown`, `bookdown`, `knitr`, `palmerpenguins`, `tidyverse`, `renv`, `haven`, `readr` 및 `tidyverse` 패키지가 사용됨을 나타냅니다.

원하는 경우 잠금 파일("renv.lock")을 열어 정확한 버전을 확인할 수 있습니다. 잠금 파일은 설치된 다른 모든 패키지와 다운로드한 위치도 문서화합니다. 외부에서 이 프로젝트에 오는 사람은 `restore()`를 사용하여 우리가 사용한 패키지의 정확한 버전을 설치할 수 있습니다.

### 코드 린팅 및 스타일링

빠른 것이 가치가 있지만 대부분 빠른 반복이 가능한 것이지 반드시 코드가 빠르게 실행되는 것은 아닙니다.\index{efficiency!code} @oldlanguages [p. 26]는 1954년에도 프로그래머가 컴퓨터만큼이나 비용이 많이 들었고 요즘에는 추가적인 계산 능력이 프로그래머보다 훨씬 저렴하다고 설명합니다. 성능 좋은 코드는 중요하지만 다른 사람의 시간을 효율적으로 사용하는 것도 중요합니다. 코드는 거의 한 번만 작성되지 않습니다. 대신 실수를 수정하기 위해서라도 일반적으로 다시 돌아와야 하며, 이는 코드를 사람이 읽을 수 있어야 함을 의미합니다[@beautifulcode, p. 478]. 이것이 이루어지지 않으면 효율성 비용이 발생합니다.

린팅\index{code!linting}과 스타일링은 코드를 확인하고, 주로 스타일 문제를 확인하고, 코드를 더 읽기 쉽게 재정렬하는 과정입니다. (린팅의 또 다른 측면은 닫는 괄호를 잊는 것과 같은 프로그래밍 오류를 처리하는 것이지만, 여기서는 스타일 문제에 중점을 둡니다.) 종종 최고의 효율성 향상은 다른 사람이 코드를 더 쉽게 읽을 수 있도록 하는 데서 비롯되며, 이는 휴식 후 코드로 돌아오는 자신일지라도 마찬가지입니다. 미국 독점 거래 회사인 제인 스트리트\index{Jane Street}는 위험 완화의 핵심 부분으로 코드를 읽기 쉽게 만드는 데 매우 중점을 둡니다[@minsky2011ocaml]. 우리 모두가 코드의 잠재적으로 변덕스러운 관리에 수십억 달러를 가지고 있지는 않겠지만, 우리 모두는 코드가 오류를 생성하지 않기를 바랄 것입니다.

`lintr`의 `lint()`를 사용하여 코드를 린트합니다. 예를 들어, 다음 R 코드를 고려하십시오("linting_example.R"로 저장됨).

```{r}
#| include: true
#| message: false
#| warning: false
#| eval: false

SIMULATED_DATA <-
  tibble(
    division = c(1:150, 151),
    party = sample(
      x = c("Liberal"),
      size = 151,
      replace = T
    )
  )
```

```{r}
#| echo: true
#| eval: false

lint(filename = "linting_example.R")
```

결과는 "linting_example.R" 파일이 열리고 `lint()`가 발견한 문제가 "마커"에 인쇄된다는 것입니다(@fig-linter). 그런 다음 문제를 처리하는 것은 사용자에게 달려 있습니다.

![예제 R 코드의 린팅 결과](figures/linter.png){#fig-linter width=90% fig-align="center"}

권장 변경 사항을 적용하면 @tidyversestyleguide에서 정의한 모범 사례와 일치하고 더 읽기 쉬운 코드가 됩니다.

```{r}
#| include: true
#| message: false
#| warning: false
#| eval: false

simulated_data <-
  tibble(
    division = c(1:150, 151),
    party = sample(
      x = c("Liberal"),
      size = 151,
      replace = TRUE
    )
  )
```

처음에는 린터\index{code!linting}가 식별하는 후행 공백이나 큰따옴표만 사용하는 것과 같은 일부 측면이 작고 중요하지 않은 것처럼 보일 수 있습니다.\index{efficiency!fix the small stuff} 그러나 더 큰 문제를 해결하는 데 방해가 됩니다. 또한 작은 것을 제대로 처리하지 못하면 어떻게 큰 것을 제대로 처리할 수 있다고 누가 믿을 수 있겠습니까? 따라서 린터가 식별하는 모든 작은 측면을 처리하는 것이 중요합니다.

`lintr` 외에도 `styler`도 사용합니다. 이것은 문제 목록을 제공하는 린터와 달리 스타일 문제를 자동으로 조정합니다. 이를 실행하려면 `style_file()`을 사용합니다.

```{r}
#| echo: true
#| eval: false

style_file(path = "linting_example.R")
```

이렇게 하면 공백 및 들여쓰기와 같은 변경 사항이 자동으로 적용됩니다. 따라서 변경 사항을 검토하고 오류가 발생하지 않았는지 확인하기 위해 프로젝트가 끝날 때 한 번만 수행하는 것이 아니라 정기적으로 수행해야 합니다.


### 코드 검토

이러한 모든 스타일 측면을 처리한 후 코드 검토\index{code!review}로 전환할 수 있습니다.\index{efficiency!code review} 이것은 다른 사람이 코드를 살펴보고 비평하는 과정입니다. 많은 전문 작가에게는 편집자가 있으며 코드 검토는 데이터 과학에서 가장 가까운 것입니다. 코드 검토는 코드 작성의 중요한 부분이며 @researchsoftware [p. 465]는 이를 "버그를 찾는 가장 효과적인 방법"이라고 설명합니다. 피드백을 받는 것이 개선하는 좋은 방법이기 때문에 코딩을 배울 때 특히 도움이 되지만 상당히 부담스러울 수 있습니다.

다른 사람의 코드를 검토할 때는 정중하고 동료애를 발휘하도록 노력하십시오.\index{help!providing} 공백 및 구분과 같은 작은 측면은 린터와 스타일러가 처리했어야 하지만 그렇지 않은 경우 일반적인 권장 사항을 제시하십시오. 데이터 과학에서 코드 검토자로서 대부분의 시간은 다음과 같은 측면에 할애해야 합니다.

1) 정보성 README가 있고 어떻게 개선할 수 있습니까?
2) 파일 이름과 변수 이름이 일관되고 정보가 풍부하며 의미가 있습니까?
3) 주석을 통해 무언가를 하는 이유를 이해할 수 있습니까?
4) 테스트가 적절하고 충분합니까? 고려되지 않은 엣지 케이스나 코너 솔루션이 있습니까? 마찬가지로 제거할 수 있는 불필요한 테스트가 있습니까?
5) 변수로 변경하고 설명할 수 있는 매직 넘버가 있습니까?
6) 변경할 수 있는 중복 코드가 있습니까?
7) 해결해야 할 미해결 경고가 있습니까?
8) 더 작은 것으로 나눌 수 있는 특히 큰 함수나 파이프가 있습니까?
9) 프로젝트 구조가 적절합니까?
10) 코드 중 일부를 데이터로 변경할 수 있습니까[@researchsoftware, p. 462]?

예를 들어, 총리와 대통령의 이름을 찾는 코드를 생각해 보십시오. 이 코드를 처음 작성했을 때 관련 이름을 코드에 직접 추가했을 가능성이 높습니다. 그러나 코드 검토의 일환으로 대신 이를 변경하도록 권장할 수 있습니다. 관련 이름의 작은 데이터셋을 만들고 해당 데이터셋을 조회하도록 코드를 다시 작성하도록 권장할 수 있습니다.

코드 검토는 코드를 최소한 다른 한 사람이 이해할 수 있도록 보장합니다. 이것은 세상에 대한 지식을 구축하는 데 중요한 부분입니다. Google에서는\index{Google} 코드 검토가 주로 결함을 찾는 것이 아니라(그럴 수도 있지만) 가독성과 유지 관리성을 보장하고 교육을 제공하는 것입니다[@codereview]. 제인 스트리트\index{Jane Street}에서도 마찬가지이며, 버그를 잡고, 기관 지식을 공유하고, 교육을 지원하고, 직원이 읽을 수 있는 코드를 작성하도록 의무화하기 위해 코드 검토를 사용합니다[@ocamlyaronpodcast].

마지막으로 코드 검토는 모든 코드를 읽는 번거로운 며칠이 걸리는 과정일 필요도 없고 그래서도 안 됩니다. 최고의 코드 검토는 단 몇 줄의 변경 사항을 제안하는 데 초점을 맞춘 단일 파일에 대한 빠른 검토입니다. 실제로 한 개인이 아니라 소규모 팀이 검토하는 것이 더 나을 수 있습니다. 한 번에 너무 많은 코드를 검토하지 마십시오. 최대 몇 백 줄 정도이며 약 1시간이 걸립니다. 그 이상은 효능 감소와 관련이 있는 것으로 밝혀졌습니다[@cohen2006best, p. 79].

### 코드 리팩토링

코드 리팩토링\index{code!refactor}이란 새 코드가 이전 코드와 동일한 결과를 달성하지만 새 코드가 더 잘 수행하도록 코드를 다시 작성하는 것을 의미합니다.\index{efficiency!code} 예를 들어, @refactornature는 중요한 영국 Covid 모델을 뒷받침하는 코드가 처음에 역학자\index{epidemiology}에 의해 작성되었고 몇 달 후 왕립 학회, Microsoft 및 GitHub 팀에 의해 명확해지고 정리되었다고 논의합니다. 이는 동일한 입력을 고려할 때 두 버전 모두 동일한 출력을 생성했지만 모델에 대한 신뢰도를 높였기 때문에 가치가 있었습니다.\index{confidence!establishing}

일반적으로 다른 사람이 작성한 코드와 관련하여 코드 리팩토링을 참조합니다. (실제로 우리가 코드를 작성했을 수도 있고, 단지 얼마 전이었을 수도 있습니다.) 코드 리팩토링을 시작할 때 다시 작성된 코드가 원래 코드와 동일한 결과를 달성하는지 확인하고 싶습니다. 즉, 의존할 수 있는 적절한 테스트 모음이 작성되어 있어야 합니다. 이러한 테스트가 없으면 만들어야 할 수도 있습니다.\index{code!tests}

다른 사람이 더 쉽게 이해할 수 있도록 코드를 다시 작성하여 결론에 대한 신뢰도를 높입니다.\index{confidence!establishing} 그러나 그렇게 하기 전에 기존 코드가 무엇을 하는지 이해해야 합니다. 시작하는 한 가지 방법은 코드를 살펴보고 광범위한 주석을 추가하는 것입니다. 이러한 주석은 일반적인 주석과 다릅니다. 각 코드 청크가 무엇을 하려고 하는지, 그리고 이것을 어떻게 개선할 수 있는지 이해하려는 적극적인 과정입니다.

코드를 리팩토링하는 것은 모범 사례를 충족하는지 확인하는 기회입니다.\index{code!best practice} @Trisovic2022는 다음을 포함하여 9,000개의 R 스크립트를 검토한 결과를 바탕으로 몇 가지 핵심 권장 사항을 자세히 설명합니다.

1. `setwd()` 및 모든 절대 경로를 제거하고 ".Rproj" 파일과 관련된 상대 경로만 사용하도록 합니다.
2. 명확한 실행 순서가 있는지 확인합니다. 처음에는 파일 이름에 숫자를 사용하여 이를 달성하도록 권장했지만 결국 `targets`[@targets]와 같은 더 정교한 접근 방식을 대신 사용할 수 있습니다.
3. 코드가 다른 컴퓨터에서 실행될 수 있는지 확인합니다.

예를 들어, 다음 코드를 고려하십시오.

```{r}
#| eval: false

setwd("/Users/rohanalexander/Documents/telling_stories")

library(tidyverse)

d = read_csv("cars.csv")

mtcars =
  mtcars |>
  mutate(K_P_L = mpg / 2.352)

library(datasauRus)

datasaurus_dozen
```

R 프로젝트를 만들어 `setwd()`를 제거하고, 모든 `library()` 호출을 맨 위에 그룹화하고, "=" 대신 "<-"를 사용하고, 변수 이름과 일관성을 유지하여 변경할 수 있습니다.

```{r}
#| eval: false

library(tidyverse)
library(datasauRus)

cars_data <- read_csv("cars.csv")

mpg_to_kpl_conversion_factor <- 2.352

mtcars <-
  mtcars |>
  mutate(kpl = mpg / mpg_to_kpl_conversion_factor)
```


## 결론

이 장에서 우리는 많은 것을 다루었으며 압도감을 느끼는 것은 정상입니다. 필요에 따라 Quarto 섹션으로 돌아오십시오. 많은 사람들이 Git과 GitHub에 대해 혼란스러워하며 그럭저럭 사용할 수 있을 만큼만 알고 있습니다. 그리고 효율성에 많은 내용이 있었지만 성능 좋은 코드의 가장 중요한 측면은 다른 사람이 읽기 쉽게 만드는 것입니다. 심지어 그 사람이 휴식 후 돌아온 자신일지라도 말입니다.




## 연습 문제

### 연습 {.unnumbered}

1. *(계획)* 다음 시나리오를 고려하십시오. *특정 국가에서는 의회 의석을 차지할 수 있는 정당이 항상 4개뿐입니다. 특정 의석과 관련된 지역에서 과반수 득표를 한 후보가 해당 의석을 차지합니다. 의회는 총 175석으로 구성됩니다. 분석가는 의석별 각 정당의 득표 수에 관심이 있습니다.* 데이터셋이 어떻게 생겼는지 스케치한 다음 모든 관찰 결과를 보여주는 그래프를 스케치하십시오.
2. *(시뮬레이션)* 설명된 시나리오를 더 자세히 고려하고 상황을 시뮬레이션하십시오. 아래 코드를 사용하여 적절한 상황을 신중하게 지정하십시오. 그런 다음 시뮬레이션된 데이터를 기반으로 5가지 테스트를 작성하십시오.

```{r}
#| eval: false
#| echo: true

library(tidyverse)

election_results <-
  tibble(
    seat = rep(1:175, each = 4),
    party = rep(x = 1:4, times = 175),
    votes = runif(n = 175 * 4, min = 0, max = 1000) |> floor()
  )
```

3. *(획득)* 관심 있는 국가의 투표에 대한 실제 데이터 출처를 지정하십시오.
4. *(탐색)* 다음 코드로 시작하여 각 정당이 획득한 의석 수 표를 만드십시오.

```{r}
#| eval: false
#| echo: true

library(tidyverse)

election_results |>
  slice_max(votes, n = 1, by = seat) |>
  count(party) |>
  tt()
```

5. *(공유)* 식별한 출처에서 데이터를 수집한 것처럼(시뮬레이션 대신) 그리고 시뮬레이션된 데이터를 사용하여 만든 표가 실제 상황을 반영하는 것처럼 두 단락을 작성하십시오. 단락에 포함된 정확한 세부 정보는 사실일 필요는 없지만 합리적이어야 합니다(즉, 실제로 데이터를 가져오거나 그래프를 만들 필요는 없습니다). 코드를 R 파일과 Quarto 문서로 적절하게 분리하십시오. README가 있는 GitHub 리포지토리에 대한 링크를 제출하십시오.

### 퀴즈 {.unnumbered}

1. @Gelman2016에 따르면 연구자들이 데이터 분석의 유연성을 이용하여 유의미한 결과를 찾는 것을 의미하는 통계적 개념은 무엇입니까 (하나 선택)?
    a. 무작위 표본 추출.
    b.  P-해킹.
    c. 귀무 가설 검정.
    d. 베이즈 추론.
2. @Gelman2016에 따르면 "p-해킹"이란 무엇입니까 (하나 선택)?
    a. p-값을 수정하는 방법.
    b.  유의미하지 않은 결과가 유의미해질 때까지 데이터 또는 분석을 조작하는 것.
    c. 계산 효율성을 향상시키는 기술.
    d. 데이터 공유에 대한 윤리적 접근 방식.
3. @Gelman2016에 따르면 파일 서랍 문제란 무엇입니까 (하나 선택)?
    a.  유의미한 결과만 게시함으로써 발생하는 편향.
    b. 보관된 데이터에 액세스하는 데 어려움.
    c. 데이터 코딩 및 입력 오류.
    d. 오래된 실험을 복제하는 데 어려움.
4. @Gelman2016에 따르면 긍정적인 결과만 게시하는 경향을 나타내는 용어는 무엇입니까 (하나 선택)?
    a. 데이터 마이닝.
    b.  출판 편향.
    c. 확증 편향.
    d. 표본 추출 오류.
5. @Gelman2016에 따르면 연구자들이 유의미한 결과로 이어질 수 있는 데이터 분석에서 갖는 다양한 선택을 설명하는 용어는 무엇입니까 (하나 선택)?
    a.  연구자 자유도.
    b. 데이터 마이닝.
    c. 표본 편향.
    d. 효과 크기 조작.
6. @Gelman2016에 따르면 갈림길의 정원은 어떤 문제를 의미합니까 (하나 선택)?
    a. 머신 러닝에서 의사 결정 트리의 복잡성.
    b.  동일한 데이터로 수행할 수 있는 여러 잠재적 분석.
    c. 시간이 지남에 따라 이론과 응용 작업의 분기.
    d. 학문 분야의 분기.
7. @Gelman2016에 따르면 연구에서 "복제"란 무엇입니까 (하나 선택)?
    a.  새로운 데이터를 사용하여 원래 결과를 재현하는 연구.
    b. 이전 방법론을 비판하는 연구.
    c. 여러 연구에 대한 메타 분석.
    d. 원래 연구 원고의 정확한 사본.
8. @Gelman2016에 따르면 사회 과학에서 재현 불가능한 결과에 기여하는 것은 무엇입니까 (하나 선택)?
    a. 부적절한 표본 크기.
    b. 고급 통계 소프트웨어 부족.
    c.  선택적 보고로 이어지는 연구자 자유도.
    d. 질적 데이터에 대한 과도한 의존.
9. @Gelman2016에 따르면 복제 위기란 무엇을 의미합니까 (하나 선택)?
    a. 새로운 이론을 만드는 데 어려움.
    b. 유사한 연구의 과잉 생산.
    c.  이전 연구 결과를 복제하는 데 어려움.
    d. 실험 참가자 부족.
10. @Gelman2016에 따르면 복제 위기를 완화하는 데 도움이 되는 것은 무엇입니까 (하나 선택)?
    a. 데이터 기밀 유지.
    b. 유의미한 결과만 게시.
    c.  연구 및 분석 계획 사전 등록.
    d. 독점 소프트웨어 사용 증가.
11. @Gelman2016은 심리학의 복제 위기에 초점을 맞춥니다. 자신의 경험을 바탕으로 다른 수업에서와 같이 다른 분야를 선택하고 해당 분야에서 복제 문제가 어느 정도 있을 수 있는지, 그리고 그 이유에 대해 작성하십시오.
12. 익숙한 분야를 선택하십시오. 해당 분야에서 재현성을 향상시킬 수 있는 관행은 무엇입니까? 간략한 설명을 제공하십시오.
13. @wilsongoodenough에 따르면 다음 중 중요한 데이터 관리 관행은 무엇입니까 (모두 선택)?
    a.  원시 데이터와 정리된 버전을 모두 저장합니다.
    b.  데이터 처리 단계를 문서화합니다.
    c.  데이터 저장을 위해 비독점 파일 형식을 사용합니다.
14. @wilsongoodenough에 따르면 프로젝트의 홈 디렉터리에 README 파일을 만드는 것이 중요한 이유는 무엇입니까 (하나 선택)?
    a. 원시 데이터 파일을 저장하기 위해.
    b.  프로젝트의 목적을 설명하고 개요를 제공하기 위해.
    c. 프로젝트의 모든 오류와 버그를 나열하기 위해.
    d. 프로젝트 파일의 모든 버전을 추적하기 위해.
15. @wilsongoodenough에 따르면 버전 관리를 사용하는 주요 이점은 무엇입니까 (하나 선택)?
    a. 연구원을 위해 코드를 자동으로 작성합니다.
    b.  변경 사항을 추적하고 공동 작업을 돕습니다.
    c. 데이터 백업의 필요성을 대체합니다.
    d. 모든 데이터가 암호화되도록 보장합니다.
16. @wilsongoodenough에 따르면 프로젝트에서 파일 이름을 지정하는 권장 관행은 무엇입니까 (하나 선택)?
    a.  파일 이름에 내용이나 기능을 반영합니다.
    b. result1.csv, result2.csv와 같은 순차 번호 사용.
    c. 파일 이름을 고유하게 만들기 위해 특수 문자 포함.
    d. 파일 이름에 공백 및 구두점 사용.
17. @wilsongoodenough에 따르면 원시 데이터의 수정되지 않은 사본을 저장해야 하는 이유는 무엇입니까 (하나 선택)?
    a. 데이터 저장 공간을 절약하기 위해.
    b. 법적 규정을 준수하기 위해.
    c.  검증 및 재현성을 위해 변경되지 않은 출처를 보장하기 위해.
    d. 소프트웨어 업데이트와의 호환성을 유지하기 위해.
18. @wilsongoodenough에 따르면 개방형 파일 형식을 사용하는 주요 이점은 무엇입니까 (하나 선택)?
    a. 처리 속도가 더 빠릅니다.
    b.  독점 소프트웨어 없이 액세스할 수 있습니다.
    c. 데이터를 더 효율적으로 압축합니다.
    d. 데이터 보안을 강화합니다.
19. @wilsongoodenough에 따르면 다음 중 데이터 파일을 구성할 때 권장되는 관행은 무엇입니까 (모두 선택)?
    a.  의미 있고 일관된 파일 이름을 사용합니다.
    b. 모든 파일을 단일 폴더에 저장합니다.
    c.  파일을 명확한 디렉터리 구조로 구성합니다.
    d. 버전 추적을 위해 파일 이름에 날짜를 포함합니다.
20. @wilsongoodenough에 따르면 데이터 처리 단계를 문서화하는 것이 중요한 이유는 무엇입니까 (하나 선택)?
    a. 데이터 분석 속도를 높입니다.
    b. 데이터 암호화에 도움이 됩니다.
    c. 저장 요구 사항을 줄입니다.
    d.  다른 사람이 분석을 이해하고 재현할 수 있도록 합니다.
21. 재현성의 이점은 무엇입니까?
    a.  결과를 독립적으로 확인할 수 있습니다.
    b. 코드 실행 속도를 높입니다.
    c. 데이터 시각화를 더 쉽게 만듭니다.
    d. 문서화의 필요성을 줄입니다.
22. @Alexander2019에 따르면 연구는 다음과 같은 경우 재현 가능합니다 (하나 선택).
    a. 동료 심사를 거친 저널에 게시됩니다.
    b. 연구에 사용된 모든 자료가 제공됩니다.
    c. 저자가 자료를 제공하지 않고도 정확하게 재현할 수 있습니다.
    d.  연구에 사용된 모든 자료가 주어지면 정확하게 재현할 수 있습니다.
23. 문학적 프로그래밍이란 무엇입니까 (하나 선택)?
    a. 코드와 문서를 다른 파일로 분리합니다.
    b. 코드의 구문 오류를 자동으로 수정합니다.
    c. 코드 문서 생성을 자동화합니다.
    d.  동일한 문서에 코드와 자연어를 통합합니다.
24. 재현 가능한 워크플로에서 git의 주요 기능은 무엇입니까 (하나 선택)?
    a. 데이터 정리 자동화.
    b. 병렬로 코드 실행.
    c. 보고서에 데이터 시각화 통합.
    d.  코드에 대한 버전 관리 시스템 제공.
25. @tidyversestyleguide에 따르면 "00_get_data.R"과 "get data.R" 파일은 어떻게 분류됩니까 (하나 선택)?
    a. 나쁨; 나쁨.
    b.  좋음; 나쁨.
    c. 나쁨; 좋음.
    d. 좋음; 좋음.
26. 재현 가능한 연구에 Quarto를 사용하는 이점은 무엇입니까 (하나 선택)?
    a. 통계 분석을 자동화합니다.
    b.  코드와 텍스트를 통합합니다.
    c. 버전 관리의 필요성을 대체합니다.
    d. 데이터 시각화 기능을 향상시킵니다.
27. Quarto에서 최상위 제목은 어떻게 표시합니까 (하나 선택)?
    a. ### 제목
    b. **제목**
    c.  # 제목
    d. - 제목
28. 다음 중 Quarto에서 굵은 텍스트를 만드는 것은 무엇입니까 (하나 선택)?
    a.  `**굵게**`
    b. `##굵게##`
    c. `*굵게*`
    d. `#굵게#`
29. Quarto R 코드 청크에서 "echo" 옵션은 무엇을 합니까 (하나 선택)?
    a. 코드 출력을 표시하지 않기 위해.
    b.  코드가 문서에 표시되는지 여부를 제어하기 위해.
    c. 코드를 조건부로 평가하기 위해.
    d. 출력에 경고를 포함하기 위해.
30. Quarto R 청크에서 경고를 숨기는 옵션은 무엇입니까 (하나 선택)?
    a. `echo: false`
    b. `eval: false`
    c.  `warning: false`
    d. `message: false`
31. Quarto R 청크에서 R 코드 청크를 실행하고 결과를 표시하지만 코드는 표시하지 않는 옵션은 무엇입니까 (하나 선택)?
    a.  `echo: false`
    b. `include: false`
    c. `eval: false`
    d. `warning: false`
    e. `message: false`
32. R 프로젝트가 중요한 이유는 무엇입니까 (모두 선택)?
    a.  재현성에 도움이 됩니다.
    b.  코드 공유를 더 쉽게 만듭니다.
    c.  작업 공간을 더 체계적으로 만듭니다.
33. R 프로젝트 이름이 리포지토리 내용을 반영하는 것이 중요한 이유는 무엇입니까 (모두 선택)?
    a.  일관성.
    b.  전문성.
    c.  세부 사항에 대한 주의.
34. 패키지와 데이터셋이 로드되었다고 가정합니다. 이 코드의 실수는 무엇입니까: `DoctorVisits |> filter(visits)` (하나 선택)?
    a. `DoctorVisits`
    b. `|>`
    c.  `filter`
    d. `visits`
35. reprex란 무엇이며 하나를 만들 수 있는 것이 중요한 이유는 무엇입니까 (모두 선택)?
    a.  오류를 재현할 수 있는 재현 가능한 예제.
    b.  다른 사람이 당신을 돕는 데 도움이 되는 재현 가능한 예제.
    c.  구성 중에 자신의 문제를 해결할 수 있는 재현 가능한 예제.
    d.  실제로 자신을 돕기 위해 노력했음을 보여주는 재현 가능한 예제.
36. @sharlatalks에 따르면 "막힌 곳에서 벗어나려면 첫 번째 단계는 reprex 또는 재현 가능한 예제를 만드는 것입니다. reprex의 목표는 문제가 있는 코드를 다른 사람이 실행하고 당신의 고통을 느낄 수 있도록 패키지하는 것입니다. 그런 다음 바라건대 그들이 해결책을 제공하고 당신을 고통에서 벗어나게 할 수 있습니다."의 핵심 부분은 무엇입니까 (하나 선택)?
    a. 문제가 있는 코드 패키지하기
    b.  다른 사람이 실행하고 당신의 고통을 느낄 수 있도록
    c. 첫 번째 단계는 reprex 만들기
    d. 그들이 해결책을 제공하고 당신을 고통에서 벗어나게 할 수 있도록
37. @sharlatalks에 따르면 도움을 요청할 때 재현 가능한 예제를 만드는 것이 중요한 이유는 무엇입니까 (하나 선택)?
    a. 문서화의 필요성을 줄입니다.
    b. 코딩 기술을 보여줍니다.
    c.  다른 사람이 문제를 복제하고 해결책을 제공할 수 있도록 합니다.
    d. 소프트웨어 라이선스를 준수합니다.
38. 다른 사람과 공동 작업할 때 코드 효율성을 향상시키는 관행은 무엇입니까 (하나 선택)?
    a. 절대 파일 경로 사용.
    b.  명확한 주석 및 문서 작성.
    c. 함수 사용 최소화.
    d. 지적 재산권을 보호하기 위해 코드 난독화.
39. 다음 중 버전 관리에 Git을 사용하는 이점은 무엇입니까 (모두 선택)?
    a.  시간 경과에 따른 변경 사항 추적.
    b.  여러 사용자 간의 공동 작업 촉진.
    c. 데이터 백업 자동화.
    d. 코드 실행 속도 향상.
40. `R` 스크립트에서 `setwd()`를 사용하지 않는 이유는 무엇입니까 (하나 선택)?
    a. 코드 실행 속도를 늦출 수 있습니다.
    b. 관리자 권한이 필요합니다.
    c.  코드를 덜 이식 가능하고 재현 가능하게 만듭니다.
    d. 최근 R 버전에서는 더 이상 사용되지 않습니다.
41. 재현성의 맥락에서 `renv` 패키지의 기능은 무엇입니까 (하나 선택)?
    a. 병렬로 코드 청크 실행.
    b.  소프트웨어 환경 문서화 및 공유.
    c. 코드 린팅 자동화.
    d. 시뮬레이션에서 코드 효율성 향상.
42. 다음 중 재현 가능한 워크플로에 기여하지 않는 것은 무엇입니까 (하나 선택)?
    a.  작업 디렉터리를 설정하기 위해 `setwd()` 사용.
    b. 결과뿐만 아니라 코드와 데이터 공유.
    c. 논문에서 R 및 Python 코드를 통합하기 위해 Quarto 사용.
    d. Git 및 GitHub를 사용한 버전 관리.
43. @tidyversestyleguide에 따르면 다음 변수 이름 중 권장 스타일을 따르는 것은 무엇입니까 (하나 선택)?
    a. total-Sales
    b. TotalSales
    c.  total_sales
    d. total sales
44. `R`에서 `lintr` 패키지의 주요 기능은 무엇입니까 (하나 선택)?
    a. 병렬로 코드 실행.
    b. 패키지 종속성 설치.
    c.  스타일 일관성을 위한 코드 린팅 제공.
    d. 데이터 분포 시각화.
45. 코드 리팩토링이란 무엇입니까 (하나 선택)?
    a. 오류를 수정하기 위해 코드 디버깅.
    b.  동작을 변경하지 않고 구조를 개선하기 위해 코드 다시 작성.
    c. 기존 코드에 새 기능 추가.
    d. 한 언어에서 다른 언어로 코드 변환.
46. 코드에서 "매직 넘버"를 피해야 하는 이유는 무엇입니까 (하나 선택)?
    a. 실행 속도를 늦춥니다.
    b.  코드 가독성과 유지 관리성을 저하시킵니다.
    c. 특정 소프트웨어와 호환되지 않습니다.
    d. 구문 오류를 유발합니다.
47. 코드를 작성할 때 린터를 사용하는 주요 목적은 무엇입니까 (하나 선택)?
    a. 알고리즘의 논리적 오류 찾기.
    b. 코드를 더 빠르게 실행하기 위해.
    c.  코딩 스타일 가이드라인 적용.
    d. 코드를 기계어로 컴파일하기 위해.
48. 재현성의 맥락에서 "미래의 당신"이란 무엇을 의미합니까 (하나 선택)?
    a. 자동 코드 생성.
    b.  나중에 코드를 이해하고 재사용할 수 있는 능력.
    c. 코드의 예측 분석.
    d. 미래 동료와의 공동 작업.


### 수업 활동 {.unnumbered}

- [스타터 폴더](https://github.com/RohanAlexander/starter_folder)를 사용하고 새 리포지토리를 만듭니다. 수업의 공유 Google 문서에 GitHub 리포지토리 링크를 추가합니다.
- Quarto를 사용하여 제목, 작성자 및 초록이 있는 PDF를 만듭니다.^[항상 소수의 학생들이 로컬에서 PDF를 설정하는 데 어려움을 겪습니다. 최악의 경우 다른 모든 작업을 로컬에서 html로 수행한 다음 Posit Cloud에서 PDF를 빌드합니다.]
- `palmerpenguins::penguins`에 대해 종별 평균 부리 길이를 생성하는 세 개의 섹션과 일부 코드를 추가합니다(코드 자체는 숨김).
- R 및 `palmerpenguins`에 대한 인용을 추가한 다음 성별에 따른 체질량 그래프를 추가합니다.
- 그래프에 대한 텍스트 단락과 상호 참조를 추가합니다. 또한 연도별 종 수에 대한 표를 추가합니다.
- [강사는 이 모든 것을 (매우 느리게) 라이브 코딩하고 학생들이 따라 하도록 해야 합니다.] 로컬 컴퓨터에 git을 설정합니다.^[GitHub 이메일을 숨긴 경우 로컬에서 이메일 주소를 추가할 때 별칭을 사용해야 합니다.] GitHub 리포지토리를 만들고 로컬 복사본을 만들고 일부 변경 사항을 적용하고 푸시합니다.^[항상 몇몇 학생들은 로컬에서 git을 작동시키지 못합니다. 가장 좋은 방법은 시연하는 동안 고급 학생과 짝을 지어 분류하고 남은 문제가 있으면 사무실 시간에 개별적으로 처리하는 것입니다.]
- 파트너의 GitHub 리포지토리를 찾아 포크하고 변경 사항을 적용하고 풀 리퀘스트를 만듭니다.
- 다음 코드는 오류를 생성합니다. @sec-dealingwitherrors의 전략에 따라 수정하십시오.
```{r}
#| eval: false

tibble(year = 1875:1972,
       level = as.numeric(datasets::LakeHuron)) |>
  ggplot(aes(x = year, y = level)) |>
  geom_point()
```
- 다음 코드는 오류를 생성합니다. @sec-dealingwitherrors의 전략에 따라 수정하십시오.
```{r}
#| eval: false

tibble(year = 1871:1970,
       annual_nile_flow = as.character(datasets::Nile)) |>
  ggplot(aes(x = annual_nile_flow)) +
  geom_histogram()
```
- 다음 코드는 오류를 생성합니다. @sec-omgpleasemakeareprexplease에 따라 reprex를 만들고(`mtcars`와 같은 더 일반적인 데이터셋을 사용하도록 예제를 변경), GitHub Gist에 추가하고 강사에게 이메일로 보내십시오.
```{r}
#| eval: false

tibble(year = 1875:1972,
       level = as.numeric(datasets::LakeHuron)) |>
  ggplot(aes(x = year, y = level)) |>
  geom_point()
```
- 다음 코드는 오류를 생성합니다. ChatGPT 또는 동등한 LLM을 사용하여 수정하십시오. 다음을 논의하십시오. 1) 프롬프트, 2) 수정된 코드.
```{r}
#| eval: false

penguins |>
  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, color = species)) |>
  geom_point()
```


### 과제 I {.unnumbered}

이 과제의 목적은 동료 검토를 주고받는 것입니다. 일반적으로 동료 검토, 특히 코드 검토[@codereview]는 전문가로서 일하는 데 중요한 부분입니다.

먼저 `usethis::git_vaccinate()`를 실행하십시오. 그런 다음 @sec-fire-hose의 활동에서 [스타터 폴더](https://github.com/rohanalexander/starter_folder)를 사용하도록 작업을 업데이트하십시오. 여기에는 무엇보다도 다운로드 및 정리를 적절한 스크립트로 이동하고 README를 업데이트하고 제목을 추가하는 등의 작업이 포함됩니다. 일반적으로 [온라인 부록 -@sec-papers]의 *Donaldson* 논문에 대한 채점 기준을 살펴보고 너무 많은 추가 작업을 하지 않고 가능한 한 많이 준수하도록 노력해야 합니다. 그런 다음 다른 사람과 교환하십시오.

@googlecoderview 및 @giladpeerreview를 읽으십시오. 그런 다음 GitHub Issues를 사용하여 리포지토리 내용에 대한 동료 검토를 수행하십시오. @giladpeerreview에 따라 동료 검토는 다음 구조를 사용해야 하며 보기 좋게 형식을 지정해야 합니다.

1. 요약
    *[검토 중인 원고에 대한 간략한 요약을 추가하십시오.]*
2. 강력한 긍정적 측면:
    *[간단하게 유지하십시오. 두세 개의 항목입니다.]*
3. 필요한 중요한 개선 사항:
    *[이것이 가장 중요한 섹션입니다. 논문 저자가 수정 및/또는 해결해야 하는 문제입니다. 매우 건설적이고 정중하며 부드럽지만 명확하게 설명하고 저자를 돕기 위해 가능한 한 많은 정보를 제공하십시오. 여기에는 실수/오류, 누락된 정보, 간과, 오해 등이 포함될 수 있습니다. 가능하다면 이것이 왜 실수인지 설명하고 수정 사항이나 올바른 정보를 찾을 수 있는 링크를 제공하십시오.]*
4. 개선 제안:
    *[이것은 저자가 더 잘하도록 돕기 위한 것입니다. 있으면 좋은 것입니다. 확실하지 않은 사항에 대해 언급하거나 의견을 제시하거나 오타 또는 사소한 코드 문제를 지적할 수 있지만 이것이 제안이라는 점에 대해 겸손하고 매우 긍정적이고 건설적이어야 합니다. 약 5~6개의 항목이 있어야 합니다.]*
5. 평가:
    *[채점 기준의 각 요소를 추가하고 이에 대한 의견과 점수를 제공하십시오. 이것은 채점에 사용되지 않으며 저자에게 각 요소를 개선하기 위해 얼마나 많은 작업을 수행해야 하는지에 대한 아이디어를 제공하기 위한 것입니다.]*
6. 예상 총점:
    *[Y]* 점 만점에 *[X]* 점.
7. 기타 의견:
    *[기타 의견.]*


### 과제 II {.unnumbered}

이 과제의 목적은 다음에 대한 편안함을 개발하는 것입니다.

1. 콰르토, 그리고
2. Git 및 GitHub.

웹사이트는 커뮤니케이션의 중요한 부분입니다. 예를 들어, 작업 포트폴리오를 공개적으로 제공할 수 있는 장소입니다. 웹사이트를 만드는 한 가지 방법은 Quarto의 내장 웹사이트를 사용하는 것입니다. RStudio에서 GitHub를 설정하면 약 5분 안에 웹사이트를 온라인에 게시할 수 있습니다.

새 프로젝트를 만들어 시작하십시오("파일" -> "새 프로젝트" -> "새 디렉터리" -> "Quarto 웹사이트"). 이름을 지정하고 "새 세션에서 열기" -> "프로젝트 만들기"를 선택하십시오(@fig-quartoone).

::: {#fig-quartowebsiteftw layout-nrow="2" layout-valign="bottom"}

![Quarto 웹사이트 설정 예시](figures/quartoone.png){#fig-quartoone}

![Quarto 웹사이트 빌드](figures/quartotwo.png){#fig-quartotwo}

![Quarto 웹사이트 개인화](figures/quartothree.png){#fig-quartothree}

![Quarto yaml 업데이트](figures/quartofour.png){#fig-quartofour}

Quarto를 사용하여 웹사이트 만들기
:::

기본 기본 웹사이트는 "빌드" -> "웹사이트 렌더링"으로 생성할 수 있습니다(@fig-quartotwo). 기본적으로 "뷰어" 창에 표시될 수 있지만 새 창에서도 표시할 수 있습니다. 다시 말하지만, 이 시점에서 세부 정보를 자신에게 맞게 변경하고 싶을 수 있습니다. 특히 "index.qmd"의 제목을 변경하고 자신의 세부 정보를 추가하고 싶을 수 있습니다(@fig-quartothree).

기본 메뉴에 포함된 내용은 "_quarto.yml"에 지정됩니다. 여기에 "contact.qmd"와 같은 다른 페이지를 추가할 수 있으며 포함될 내용을 만들려면 "about.qmd"와 같은 페이지를 복제한 다음 편집할 수 있습니다(@fig-quartofour). "_quarto.yml"에서 변경할 수 있는 또 다른 측면은 테마입니다. 기본값은 "cosmo"이지만 [여기](https://quarto.org/docs/output-formats/html-themes.html)에 지정된 다른 많은 옵션이 있습니다.

세부 정보가 개인화되고 웹사이트에 불만이 없으면 GitHub로 푸시한 다음 GitHub Pages로 호스팅할 수 있습니다. 이를 활용하려면 먼저 두 가지 작업을 수행해야 합니다. 첫째, "_site" 대신 "docs" 폴더로 빌드하도록 지정하기 위해 "_quarto.yml"을 약간 수정해야 합니다(@fig-quartofour).

```{r}
#| eval: false
#| echo: true

project:
  type: website
  output-dir: docs
```

알아야 할 다른 측면은 이 서비스를 사용할 때 기본적으로 GitHub가 사이트를 빌드하려고 시도한다는 것입니다. 이는 원치 않는 것이므로 먼저 숨겨진 파일을 추가하여 이를 해제해야 합니다. 콘솔에서 다음을 실행합니다.

```{r}
#| eval: false
#| echo: true

file.create(".nojekyll")
```

그런 다음 GitHub가 설정되었다고 가정하면 `usethis`를 사용하여 새로 만든 프로젝트를 GitHub에 올릴 수 있습니다. `use_git()`를 사용하여 Git 리포지토리를 초기화한 다음 `use_github()`를 사용하여 GitHub로 푸시합니다.

```{r}
#| eval: false
#| echo: true

use_git()
use_github()
```

그러면 프로젝트가 GitHub에 있게 됩니다. GitHub 페이지를 사용하여 호스팅할 수 있습니다. "설정 -> 페이지"로 이동한 다음 소스를 설정에 따라 "main" 또는 "master"로 변경하고 마지막으로 "docs"로 변경합니다. 몇 분 동안 다양한 검사를 거친 후 GitHub에서 사이트를 방문하여 공유할 수 있는 주소를 알려줍니다.

사이트를 업데이트하려면 로컬에서 작업하십시오. 먼저 GitHub에서 변경한 내용이 로컬에 있는지 확인하기 위해 풀하고, 사이트를 편집하고, 다시 렌더링하고, 일반적인 방식으로 GitHub에 푸시합니다. 검사가 완료되면 라이브 웹사이트가 업데이트됩니다.

웹사이트에 일반 텍스트 단락, 섹션 제목, 글머리 기호가 있는지 확인하십시오. 모든 것이 잘 문서화되고 보기 좋게 형식이 지정되어 있으며 일반적으로 고품질이어야 합니다.

채점 기준의 관련 구성 요소는 "수업 논문", "LLM 사용량 문서화됨", "산문", "커밋" 및 "재현 가능한 워크플로"입니다. 웹사이트 링크를 제출하십시오.



### 논문 {.unnumbered}

::: {.content-visible when-format="pdf"}
이 시점에서 ["논문" 온라인 부록](https://tellingstorieswithdata.com/23-assessment.html)의 *도널드슨* 논문이 적절할 것입니다.
:::

::: {.content-visible unless-format="pdf"}
이 시점에서 [온라인 부록 -@sec-papers]의 *도널드슨* 논문이 적절할 것입니다.
:::
