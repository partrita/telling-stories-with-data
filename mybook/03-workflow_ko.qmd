---
engine: knitr
---

# 재현 가능한 워크플로우 {#sec-reproducible-workflows}

:::{.callout-note}
Chapman and Hall/CRC는 이 책을 2023년 7월에 출판했습니다. [여기](https://www.routledge.com/Telling-Stories-with-Data-With-Applications-in-R/Alexander/p/book/9781032134772)에서 구매할 수 있습니다. 이 온라인 버전은 인쇄된 내용에 일부 업데이트가 있습니다.
:::

**선행 조건**

- *What has happened down here is the winds have changed* 읽기, [@Gelman2016]
  - 복제 위기(replication crisis)와 사회 과학이 이에 대응하여 어떻게 변화했는지에 대한 개요를 제공하는 블로그 게시물입니다.
- *Good enough practices in scientific computing* 읽기, [@wilsongoodenough]
  - 컴퓨터 사용 방식에 초점을 맞춰 데이터 과학을 수행하는 방법에 대한 명확하고 쉽게 채택할 수 있는 권장 사항을 제공하는 논문입니다.
- *How to improve your relationship with your future self* 읽기, [@bowers2016improve]
  - 분석에 초점을 맞춰 데이터 과학을 수행하는 방법에 대한 명확하고 쉽게 채택할 수 있는 권장 사항을 제공하는 논문입니다.
- *Overcoming barriers to sharing code* 시청, [@monicatalks]
  - 이 비디오는 코드 공유에 익숙해지는 것에 대한 개인적인 성찰입니다.
- *Make a reprex$... Please* 시청, [@sharlatalks]
  - 이 비디오는 도움을 요청할 때 재현 가능한 예제를 만드는 것이 왜 그렇게 중요한지 자세히 설명합니다.
- *The tidyverse style guide* 읽기, [@tidyversestyleguide]
  - R에서 코딩할 때 권장되는 모범 사례를 문서화한 웹사이트입니다.
- *Code smells and feels* 시청, [@codesmells]
  - 코딩할 때 피해야 할 사항을 자세히 설명하는 비디오입니다.

**주요 개념 및 기술**

- 재현성은 일반적으로 누군가가 당신에게 부과하는 것으로 시작됩니다. 그것은 번거롭고 짜증날 수 있습니다. 이것은 일반적으로 짧은 휴식 후에 프로젝트를 다시 방문해야 할 때까지 지속됩니다. 그 시점에서 당신은 재현성이 데이터 과학의 요구 사항일 뿐만 아니라 진정한 발전을 이룰 수 있는 유일한 방법이기 때문에 우리 자신을 돕는 데 도움이 된다는 것을 깨닫게 됩니다.
- 재현성은 데이터, 코드 및 환경 공유를 의미합니다. 이는 Quarto, R 프로젝트, Git 및 GitHub를 사용하여 향상됩니다. Quarto는 일반 텍스트와 R 코드를 통합하는 문서를 구축합니다. R 프로젝트는 사용자의 개인 디렉토리 설정에 의존하지 않는 파일 구조를 가능하게 합니다. Git 및 GitHub는 코드와 데이터를 더 쉽게 공유할 수 있도록 합니다.
- 이것은 흠잡을 데 없는 워크플로우는 아니지만, 충분히 좋고 많은 이점을 제공합니다. 다양한 도구를 통해 다양한 측면을 개선할 것이지만, 코드 구조와 주석을 개선하는 것이 큰 도움이 됩니다.
- 항상 오류가 발생하며, 디버깅은 연습을 통해 향상되는 기술임을 인식하는 것이 중요합니다. 그러나 도움을 받을 수 있는 핵심 측면 중 하나는 다른 사람들이 사용할 수 있는 재현 가능한 예제를 만들 수 있다는 것입니다.

**소프트웨어 및 패키지**

- Base R [@citeR]
- `AER` [@citeaer]
- `future` [@future]
- `gitcreds` [@gitcreds]
- `lintr` [@lintr]
- `renv` [@renv]
- `reprex` [@reprex]
- `styler` [@styler]
- `tidyverse` [@tidyverse]
- `tinytable` [@tinytable]
- `tinytex` [@tinytex]
- `usethis` [@usethis]

```
#| message: false
#| warning: false

library(AER)
library(future)
library(gitcreds)
library(lintr)
library(renv)
library(reprex)
library(styler)
library(tidyverse)
library(tinytable)
library(tinytex)
library(usethis)
```


## 서론

> 기계 학습에 대해 명심해야 할 가장 중요한 점은 성능이 한 데이터 세트의 샘플로 평가되지만, 모델은 반드시 동일한 특성을 따르지 않을 수 있는 샘플에서 사용된다는 것입니다. 따라서 "90% 정확도로 평가된 모델을 사용할 것인가, 아니면 80% 정확도로 평가된 인간을 사용할 것인가"라는 질문에 대한 답은 데이터가 평가 프로세스에 따라 일반적인지 여부에 달려 있습니다. 인간은 적응력이 있지만, 모델은 그렇지 않습니다. 상당한 불확실성이 있다면 인간을 선택하십시오. 그들은 (엄청난 양의 데이터로 훈련된 모델에 비해) 패턴 인식 능력이 떨어질 수 있지만, 그들은 자신이 하는 일을 이해하고, 그것에 대해 추론할 수 있으며, 새로운 것에 직면했을 때 즉흥적으로 대처할 수 있습니다.
>
> 프랑수아 숄레, 2020년 2월 20일.

과학이 테스트 가능한 설명과 예측의 관점에서 지식을 체계적으로 구축하고 조직하는 것이라면, 데이터 과학은 이를 데이터에 집중합니다. 이는 지식을 구축, 조직 및 공유하는 것이 중요한 측면임을 의미합니다. 당신만이 할 수 있는 방식으로 지식을 한 번 만드는 것은 이 기준을 충족하지 못합니다. 따라서 재현 가능한 데이터 과학 워크플로우가 필요합니다.

@Alexander2019 는 재현 가능한 연구\index{재현성}를 사용된 모든 자료가 주어졌을 때 정확히 다시 수행할 수 있는 연구로 정의합니다. 이는 코드, 데이터 및 환경을 제공하는 것의 중요성을 강조합니다. 최소한의 기대치는 다른 사람이 당신의 코드, 데이터 및 환경을 독립적으로 사용하여 그림과 표를 포함한 결과를 얻을 수 있다는 것입니다. 아이러니하게도 학문 분야마다 재현성에 대한 정의가 다릅니다. @barba2018terminologies 는 다양한 학문 분야를 조사하고 지배적인 언어 사용이 다음 정의를 의미한다고 결론 내립니다.

- 재현 가능한 연구는 "[저자가 분석을 다시 실행하고 결과를 재현하기 위해 필요한 모든 데이터와 컴퓨터 코드를 제공하는 경우]"입니다.
- 복제는 "새로운 데이터를 수집하고 (다른 방법을 사용하여) 새로운 분석을 완료하여 다른 연구와 동일한 과학적 발견에 도달하는" 연구입니다.

우리의 목적을 위해 @nationalacademies [p. 46]의 정의를 사용합니다. "재현성은 동일한 입력 데이터, 계산 단계, 방법 및 코드, 분석 조건을 사용하여 일관된 결과를 얻는 것입니다."\index{재현성!정의} 구체적으로 무엇이라고 불리든, @Gelman2016은 다양한 사회 과학에서 재현성 부족이 얼마나 큰 문제인지 밝힙니다. 재현할 수 없는 작업은 세상에 대한 우리의 지식에 기여하지 않습니다. 이것은 낭비적이며 잠재적으로 비윤리적일 수도 있습니다. @Gelman2016 이후 많은 사회 과학 분야에서 많은 작업이 이루어졌고 상황이 약간 개선되었지만, 여전히 많은 작업이 남아 있습니다. 이는 생명 과학 [@heil2021reproducibility], 암 연구 [@Begley2012; @Mullard2021], 컴퓨터 과학 [@pineau2021improving]에서도 마찬가지입니다.\index{컴퓨터 과학}

@Gelman2016이 언급하는 몇 가지 예시는 전체적인 관점에서 그리 중요하지 않습니다. 그러나 동시에 우리는 큰 영향을 미치는 분야에서 유사한 접근 방식이 사용되는 것을 보았고 계속해서 보고 있습니다. 예를 들어, 많은 정부는 일부 주장이 신뢰성이 부족하다는 증거가 있음에도 불구하고 공공 정책을 구현하는 "넛지" 부서를 만들었습니다 [@sunstein2017economics; @nonudge; @gelmannudge].\index{공공 정책} 정부는 점점 더 공개하지 않는 알고리즘을 사용하고 있습니다 [@chouldechova18a]. 그리고 @herndon2014does 는 2007-2008년 금융 위기 이후 긴축 정책을 정당화하기 위해 정부가 사용한 경제학 연구가 재현 불가능하다는 것을 문서화합니다.\index{경제학}

최소한, 그리고 몇 가지 예외를 제외하고, 우리는 코드, 데이터 세트 및 환경을 공개해야 합니다.\index{재현성!최소} 이것들이 없으면, 어떤 발견이 무엇을 의미하는지 알기 어렵습니다 [@miyakawa2020no]. 더 평범하게는, 실수나 부주의하게 간과된 측면이 있는지 알 수 없습니다 [@merali2010computational; @hillelwayne; @natefixesmistake]. 점점 더 @buckheit1995wavelab에 따라, 우리는 논문을 광고로 간주하고, 관련 코드, 데이터 및 환경을 실제 작업으로 간주합니다. Apple의 공동 창립자인 스티브 잡스\index{Apple}는 자신의 기술에 가장 능숙한 사람들이 아무도 보지 못할 작업의 측면까지도 공개적인 측면만큼 잘 마무리되고 고품질임을 보장하는 방법에 대해 이야기했습니다 [@stevejobs]. 데이터 과학에서도 마찬가지입니다. 고품질 작업의 특징 중 하나는 README와 코드 주석이 관련 논문의 초록만큼이나 잘 다듬어져 있다는 것입니다.

워크플로우\index{워크플로우}\index{윤리!문화 및 사회적 맥락}는 문화적, 사회적 맥락 내에 존재하며, 이는 재현성 필요성에 대한 추가적인 윤리적 이유를 부과합니다. 예를 들어, @wang2018deep 은 게이 남성과 이성애자 남성의 얼굴을 구별하기 위해 신경망을 훈련합니다. (@murphy2017는 논문, 관련 문제 및 저자의 의견에 대한 요약을 제공합니다.) 이를 위해 @wang2018deep [p. 248]은 "성인, 백인, 완전히 보이는, 사용자 프로필에 보고된 성별과 일치하는" 사람들의 사진 데이터 세트가 필요했습니다. 그들은 Amazon Mechanical Turk\index{Amazon!Mechanical Turk}를 사용하여 이를 확인했습니다. Amazon Mechanical Turk는 작업자에게 특정 작업을 완료하기 위해 소액을 지불하는 온라인 플랫폼입니다. 이 작업에 대한 Mechanical Turk 작업자에게 제공된 지침은 백인 어머니와 흑인 아버지를 둔 제44대 미국 대통령 버락 오바마를 "흑인"으로 분류해야 하며, 라틴계는 인종이 아니라 민족이라는 것을 명시합니다 [@Mattson2017].\index{편향!인종} 분류 작업은 객관적으로 보일 수 있지만, 아마도 무심코 특정 계층과 배경을 가진 미국인의 견해를 반영합니다.

이것은 @wang2018deep 워크플로우의 한 부분에 대한 특정 우려 사항일 뿐입니다. @Gelman_2018 을 포함한 다른 사람들도 더 광범위한 우려를 제기합니다. 주요 문제는 통계 모델이 훈련된 데이터에 특화되어 있다는 것입니다.\index{데이터!윤리} 그리고 @wang2018deep  모델에서 발생할 수 있는 문제를 식별할 수 있는 유일한 이유는 그들이 사용한 특정 데이터 세트를 공개하지 않았음에도 불구하고 그들의 절차에 대해 공개적이었기 때문입니다. 우리의 작업이 신뢰성을 가지려면 다른 사람들도 재현할 수 있어야 합니다.

우리의 작업을 더 재현 가능하게 만들기 위해 취할 수 있는 몇 가지 단계\index{재현성}는 다음과 같습니다.

1. 전체 워크플로우가 문서화되었는지 확인합니다. 여기에는 다음과 같은 질문에 대한 답변이 포함될 수 있습니다.
    - 원본, 편집되지 않은 데이터 세트는 어떻게 얻었으며, 다른 사람들도 지속적으로 액세스할 수 있습니까?
    - 원본, 편집되지 않은 데이터를 분석된 데이터로 변환하기 위해 어떤 특정 단계가 수행되었으며, 이를 다른 사람들에게 어떻게 제공할 수 있습니까?
    - 어떤 분석이 수행되었으며, 이를 얼마나 명확하게 공유할 수 있습니까?
    - 최종 논문 또는 보고서가 어떻게 작성되었으며, 다른 사람들도 그 과정을 얼마나 따라갈 수 있습니까?
2. 처음에는 완벽한 재현성에 대해 걱정하지 않고, 대신 각 후속 프로젝트에서 개선하려고 노력합니다. 예를 들어, 다음 요구 사항은 점점 더 부담스러워지며, 첫 번째를 할 수 있을 때까지 마지막을 할 수 없다고 걱정할 필요가 없습니다.
    - 전체 워크플로우를 다시 실행할 수 있습니까?
    - 다른 사람이 전체 워크플로우를 다시 실행할 수 있습니까?
    - "미래의 당신"이 전체 워크플로우를 다시 실행할 수 있습니까?
    - "미래의 다른 사람"이 전체 워크플로우를 다시 실행할 수 있습니까?
3. 최종 논문 또는 보고서에 데이터 세트 및 접근 방식의 한계에 대한 자세한 논의를 포함합니다.

이 책에서 우리가 옹호하는 워크플로우\index{워크플로우}는 다음과 같습니다.

$$\mbox{계획}\rightarrow\mbox{시뮬레이션}\rightarrow\mbox{획득}\rightarrow\mbox{탐색}\rightarrow\mbox{공유}$$

그러나 "엄청나게 많이 생각하고, 주로 읽고 쓰고, 때로는 코딩한다"고도 생각할 수 있습니다.

이 워크플로우의 재현성을 향상시킬 수 있는 다양한 도구가 있습니다. 여기에는 Quarto, R 프로젝트, Git 및 GitHub가 포함됩니다.

## Quarto

### 시작하기

Quarto\index{Quarto}는 코드와 자연어를 "문학적 프로그래밍"이라고 불리는 방식으로 통합합니다 [@Knuth1984]. 이는 R 코드 청크를 포함하도록 특별히 설계된 Markdown의 변형인 R Markdown의 후속작입니다. Quarto는 Microsoft Word와 같은 "What You See Is What You Get" (WYSIWYG) 언어와 비교하여 HyperText Markup Language (HTML) 또는 LaTeX와 유사한 마크업 언어를 사용합니다. 이는 모든 측면이 일관적이라는 것을 의미합니다. 예를 들어, 모든 최상위 제목은 동일하게 보일 것입니다. 그러나 특정 측면이 어떻게 나타나기를 원하는지 지정하거나 "마크업"해야 합니다. 그리고 문서를 렌더링할 때만 어떻게 보이는지 확인할 수 있습니다. 시각 편집기 옵션도 사용할 수 있으며, 이는 사용자가 직접 마크업할 필요를 숨깁니다.

:::{.content-visible when-format="pdf"}
앞으로 Quarto를 사용하는 것이 합리적이지만, R Markdown\index{R!R Markdown}용으로 작성된 많은 자료가 있습니다. 이러한 이유로 [온라인 부록 "R Markdown"](https://tellingstorieswithdata.com/22-rmarkdown.html)에서 R Markdown 동등물을 제공합니다.
:::

:::{.content-visible unless-format="pdf"}
앞으로 Quarto를 사용하는 것이 합리적이지만, R Markdown\index{R!R Markdown}용으로 작성된 많은 자료가 있습니다. 이러한 이유로 [온라인 부록 -@sec-rmarkdown]에서 R Markdown 동등물을 제공합니다.
:::

:::{.callout-note}
## 거인의 어깨

페르난도 페레즈\index{페레즈, 페르난도}는 캘리포니아 대학교 버클리\index{버클리}의 통계학 부교수이자 로렌스 버클리 국립 연구소\index{통계학}의 데이터 과학 및 기술 부서의 교수 과학자입니다. 그는 콜로라도 대학교 볼더에서 입자 물리학 박사 학위를 받았습니다. 박사 학위 과정에서 그는 Python을 대화식으로 사용할 수 있게 하는 iPython을 만들었으며, 이는 현재 Project Jupyter의 기반이 되었고, R Markdown 및 현재 Quarto와 같은 유사한 노트북 접근 방식에 영감을 주었습니다. @somers2018obsolete 는 오픈 소스 노트북 접근 방식이 어떻게 선순환 피드백 루프를 생성하여 과학 컴퓨팅을 극적으로 개선하는지 설명합니다. 그리고 @romersays 는 Jupyter와 같은 오픈 소스 접근 방식의 기능을 과학적 합의와 발전을 가능하게 하는 기능과 일치시킵니다. 2017년에 페레즈는 ACM (Association for Computing Machinery) 소프트웨어 시스템 상을 수상했습니다.
:::

문학적 프로그래밍의 한 가지 장점은 코드가 실행되고 문서의 일부를 형성하는 "라이브" 문서를 얻는다는 것입니다. Quarto의 또 다른 장점은 유사한 코드가 HTML 및 PDF를 포함한 다양한 문서로 컴파일될 수 있다는 것입니다. Quarto는 또한 제목, 저자 및 날짜를 포함하는 기본 옵션을 제공합니다. 한 가지 단점은 코드가 실행되어야 하므로 문서가 컴파일되는 데 시간이 걸릴 수 있다는 것입니다.

Quarto는 [여기](https://quarto.org/docs/get-started/)에서 다운로드해야 합니다. (Posit Cloud를 사용하는 경우 이미 설치되어 있으므로 이 단계를 건너뛰십시오.) 그런 다음 RStudio 내에서 새 Quarto 문서를 만들 수 있습니다. "파일" $\rightarrow$ "새 파일" $\rightarrow$ "Quarto 문서$\dots$".

새 Quarto 문서를 열고 "소스" 보기를 선택하면, 세 개의 대시 쌍 안에 포함된 기본 [상단 내용](#Top matter)과 몇 가지 마크다운 [필수 명령](#essential commands) 및 [R 청크](#R chunks)를 보여주는 텍스트 예제를 볼 수 있으며, 각각은 다음 섹션에서 더 자세히 설명됩니다.

### 상단 내용

상단 내용은 제목, 저자, 날짜와 같은 측면을 정의하는 것으로 구성됩니다. Quarto 문서 상단의 세 개의 대시 안에 포함됩니다. 예를 들어, 다음은 제목, 문서가 렌더링된 날짜로 자동 업데이트되는 날짜, 그리고 저자를 지정합니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%d %B %Y")
format: html
---
```

초록은 논문의 짧은 요약이며, 이를 상단 내용에 추가할 수 있습니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%d %B %Y")
abstract: "이것은 내 초록입니다."
format: html
---
```

기본적으로 Quarto는 HTML 문서를 생성하지만, 출력 형식을 변경하여 PDF를 생성할 수 있습니다. 이는 백그라운드에서 LaTeX를 사용하며 지원 패키지 설치가 필요합니다. 이를 위해 `tinytex`를 설치합니다. 그러나 백그라운드에서 사용되므로 로드할 필요는 없습니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%d %B %Y")
abstract: "이것은 내 초록입니다."
format: pdf
---
```

### 참조

BibTeX\index{BibTeX} 파일을 상단 내용에 지정한 다음 필요에 따라 텍스트 내에서 호출하여 참조를 포함할 수 있습니다.

```
---
title: "내 문서"
author: "로한 알렉산더"
date: format(Sys.time(), "%d %B %Y")
format: pdf
abstract: "이것은 내 초록입니다."
bibliography: bibliography.bib
---
```

"bibliography.bib"라는 별도의 파일을 만들고 Quarto 파일 옆에 저장해야 합니다.\index{인용!BibTeX} BibTeX 파일에는 참조할 항목에 대한 항목이 필요합니다. 예를 들어, R에 대한 인용은 `citation()`으로 얻을 수 있으며 이를 "bibliography.bib" 파일에 추가할 수 있습니다.\index{인용!R} 패키지에 대한 인용은 패키지 이름을 포함하여 찾을 수 있습니다. 예를 들어 `citation("tidyverse")`를 사용하여 출력을 ".bib" 파일에 다시 추가합니다.\index{인용!R 패키지} 책이나 기사에 대한 인용을 얻으려면 [Google Scholar](https://scholar.google.com) 또는 [doi2bib](https://www.doi2bib.org)를 사용하는 것이 도움이 될 수 있습니다.\index{인용!Google Scholar}\index{인용!doi2bib}

텍스트에서 이 항목을 참조하는 데 사용할 고유 키를 만들어야 합니다.\index{인용!고유 키} 이는 고유하다면 무엇이든 될 수 있지만, "citeR"과 같이 의미 있는 키는 기억하기 더 쉬울 수 있습니다.

```
@Manual{citeR,
    title = {R: 통계 컴퓨팅을 위한 언어 및 환경},
    author = {{R Core Team}},
    organization = {R Foundation for Statistical Computing},
    address = {오스트리아 빈},
    year = {2021},
    url = {https://www.R-project.org/},
  }
@book{tellingstories,
    title = {데이터로 이야기하기},
    author = {로한 알렉산더},
    year = {2023},
    publisher = {채프먼 앤 홀/CRC},
    url = {https://tellingstorieswithdata.com}
  }
```

Quarto 문서에서 R을 인용하려면\index{인용} `@citeR`을 포함하면 연도 주위에 괄호가 붙습니다: @citeR, 또는 `[@citeR]`을 포함하면 전체 주위에 괄호가 붙습니다: [@citeR].

논문 끝의 참조 목록\index{인용}은 BibTeX 파일을 호출하고 논문에 참조를 포함하여 자동으로 생성됩니다. Quarto 문서 끝에 "# 참조"라는 제목을 포함하면 실제 인용이 그 뒤에 포함됩니다. Quarto 파일이 렌더링되면 Quarto는 내용에서 이를 보고, 필요한 참조 세부 정보를 얻기 위해 BibTeX 파일로 이동하여 참조 목록을 작성한 다음 렌더링된 문서 끝에 추가합니다.

BibTeX\index{BibTeX!대문자}는 항목의 대문자 사용을 조정하려고 시도합니다. 이는 도움이 될 수 있지만, 때로는 특정 대문자 사용을 고집하는 것이 더 좋습니다. BibTeX가 특정 대문자 사용을 강제하도록 하려면 항목 주위에 단일 중괄호 대신 이중 중괄호를 사용하십시오. 예를 들어, 위 예시에서 `{{R Core Team}}`은 정확히 그 대문자 사용으로 인쇄되지만, `{Telling Stories with Data}`는 BibTeX의 변덕에 따라 달라집니다. 특정 대문자 사용을 고집하는 것은 특정 대문자 사용이 있을 수 있는 R 패키지를 인용할 때와 조직을 저자로 인용할 때 중요합니다. 예를 들어, `usethis`를 인용할 때 `title = {{usethis: Automate Package and Project Setup}},`을 사용해야 하며, `title = {usethis: Automate Package and Project Setup},`을 사용해서는 안 됩니다. 그리고 예를 들어, 데이터가 토론토 시에서 제공되었다면, 해당 데이터 세트를 인용할 저자를 지정할 때 `author = {{City of Toronto}},`를 사용해야 하며, `author = {City of Toronto},`를 사용해서는 안 됩니다. 후자는 잘못된 참조 목록 항목인 "Toronto, City of"를 초래하는 반면, 전자는 올바른 참조 목록 항목인 "City of Toronto"를 초래합니다.


### 필수 명령

Quarto\index{Quarto}는 Markdown의 변형을 기본 구문으로 사용합니다. 필수 Markdown 명령에는 강조, 헤더, 목록, 링크 및 이미지가 포함됩니다. RStudio에는 "도움말" $\rightarrow$ "Markdown 빠른 참조"에 이러한 내용이 포함되어 있습니다. 시각 편집기를 사용할지 소스 편집기를 사용할지는 당신의 선택입니다. 그러나 어느 쪽이든, 이러한 필수 사항을 이해하는 것이 좋습니다. 왜냐하면 시각 편집기를 항상 사용할 수 있는 것은 아니기 때문입니다 (예를 들어 GitHub에서 Quarto 문서를 빠르게 볼 때). 경험이 쌓이면 Sublime Text와 같은 텍스트 편집기 또는 VS Code와 같은 대체 통합 개발 환경을 사용하는 것이 유용할 수 있습니다.

- 강조: ```*기울임꼴*```, ```**굵게**```
- 헤더 (각각 한 줄에 앞뒤로 빈 줄이 있어야 합니다):
```
         # 첫 번째 수준 헤더

         ## 두 번째 수준 헤더

         ### 세 번째 수준 헤더
```
- 하위 목록이 있는 순서 없는 목록:
```
    * 항목 1
    * 항목 2
        + 항목 2a
        + 항목 2b
```
- 하위 목록이 있는 순서 있는 목록:
```
    1. 항목 1
    2. 항목 2
    3. 항목 3
        + 항목 3a
        + 항목 3b
```
- URL을 추가할 수 있습니다: ```[이 책](https://www.tellingstorieswithdata.com)```은 [이 책](https://www.tellingstorieswithdata.com)으로 나타납니다.
- 단락은 빈 줄을 남겨서 생성됩니다.
```
아이디어에 대한 단락, 다음 단락과 적절하게 간격을 둡니다.

다른 아이디어에 대한 단락, 이전 단락과 다시 간격을 둡니다.
```

일부 측면을 추가한 후 실제 문서를 보고 싶을 수 있습니다. 문서를 빌드하려면 "렌더링"을 클릭하십시오.



### R 청크

Quarto 문서 내의 코드 청크에 R 및 기타 여러 언어에 대한 코드를 포함할 수 있습니다. 문서를 렌더링하면 코드가 실행되어 문서에 포함됩니다.

R 청크\index{Quarto!R}를 만들려면 세 개의 백틱으로 시작한 다음 중괄호 안에 Quarto에 이것이 R 청크임을 알려줍니다. 이 청크 안의 모든 것은 R 코드로 간주되어 실행됩니다. 우리는 @citeaer의 데이터를 사용합니다. 이들은 *Applied Econometrics with R* 책에 동반되는 R 패키지 `AER`를 제공합니다. `tidyverse`를 로드하고 `AER`를 설치 및 로드한 다음 설문 응답자가 지난 2주 동안 의사를 방문한 횟수에 대한 그래프를 만들 수 있습니다.

```
#| message: false
#| warning: false

library(AER)
library(tidyverse)

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

해당 코드의 출력은 [@fig-doctervisits]입니다.

```
#| label: fig-doctervisits
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| fig-cap: "1977-1978년 호주 건강 설문조사를 기반으로 한 지난 2주간의 질병 횟수"

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

청크\index{Quarto!R}에서 사용할 수 있는 다양한 평가 옵션이 있습니다. 각 옵션은 새 줄에 청크별 주석 구분 기호 "#|"로 시작하여 옵션을 포함합니다. 유용한 옵션은 다음과 같습니다.

- ```echo```: 코드 자체가 문서에 포함될지 여부를 제어합니다. 예를 들어, ```#| echo: false```는 코드가 실행되고 출력이 표시되지만, 코드 자체는 문서에 포함되지 않음을 의미합니다.
- ```include```: 코드의 출력이 문서에 포함될지 여부를 제어합니다. 예를 들어, ```#| include: false```는 코드를 실행하지만, 출력이 생성되지 않으며, 코드 자체도 문서에 포함되지 않음을 의미합니다.
- ```eval```: 코드가 문서에 포함되어야 하는지 여부를 제어합니다. 예를 들어, ```#| eval: false```는 코드가 실행되지 않으므로 포함할 출력이 없지만, 코드 자체는 문서에 포함됨을 의미합니다.
- ```warning```: 경고가 문서에 포함되어야 하는지 여부를 제어합니다. 예를 들어, ```#| warning: false```는 경고가 포함되지 않음을 의미합니다.
- ```message```: 메시지가 문서에 포함되어야 하는지 여부를 제어합니다. 예를 들어, ```#| message: false```는 메시지가 문서에 포함되지 않음을 의미합니다.

예를 들어, 출력을 포함하되 코드는 포함하지 않고 경고를 억제할 수 있습니다.

```
#| echo: false
#| warning: false

library(AER)
library(tidyverse)

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

R 청크의 양쪽에 빈 줄을 두십시오. 그렇지 않으면 제대로 실행되지 않을 수 있습니다. 그리고 논리 값에는 소문자를 사용하십시오. 즉, "false"가 아닌 "FALSE"입니다.

```
#| echo: false
#| warning: false

library(AER)
library(tidyverse)

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

Quarto 문서 자체는 필요한 모든 데이터 세트를 로드해야 합니다. 환경에 있는 것만으로는 충분하지 않습니다. 이는 Quarto 문서가 렌더링될 때 문서의 코드를 평가하기 때문이며, 반드시 환경을 평가하는 것은 아닙니다.

코드를 작성할 때 여러 줄에 걸쳐 동일한 변경을 하거나 특정 항목의 모든 인스턴스를 변경하고 싶을 수 있습니다. 이를 여러 커서로 달성합니다. 여러 연속된 줄에 걸쳐 커서를 사용하려면 Mac에서는 "option"을, PC에서는 "Alt"를 누른 상태에서 관련 줄 위로 커서를 드래그하십시오. 특정 항목의 모든 인스턴스를 선택하려면 변수 이름과 같은 하나의 인스턴스를 강조 표시한 다음 찾기/바꾸기 (Mac에서는 Command + F, PC에서는 CTRL + F)를 사용하여 "모두"를 선택하십시오. 그러면 다른 모든 인스턴스에 커서가 활성화됩니다.

### 방정식 {#sec-equations}

LaTeX\index{LaTeX}를 사용하여 방정식\index{방정식!LaTeX}\index{Quarto!방정식}을 포함할 수 있습니다. LaTeX는 TeX 프로그래밍 언어를 기반으로 합니다. 두 개의 달러 기호를 시작 및 끝 태그로 사용하여 LaTeX에서 수학 모드를 호출합니다. 그러면 그 안에 있는 모든 것이 LaTeX 마크업으로 평가됩니다. 예를 들어, 다음을 사용하여 복리 공식을 생성할 수 있습니다.

``` markdown
$$
A = P\left(1+\frac{r}{n}\right)^{nt}
$$
```

$$
A = P\left(1+\frac{r}{n}\right)^{nt}
$$

LaTeX는 포괄적인 마크업 언어이지만, 우리는 주로 관심 있는 모델을 지정하는 데 사용할 것입니다. [@sec-its-just-a-linear-model]에서 시작하여 우리가 활용할 중요한 측면을 포함하는 몇 가지 예시를 여기에 포함합니다.

``` markdown
$$
y_i|\mu_i, \sigma \sim \mbox{Normal}(\mu_i, \sigma)
$$
```

$$
y_i|\mu_i, \sigma \sim \mbox{Normal}(\mu_i, \sigma)
$$

밑줄은 아래 첨자를 얻는 데 사용됩니다: $y_i$의 경우 `y_i`. 그리고 중괄호로 묶어 하나 이상의 항목의 아래 첨자를 얻을 수 있습니다: $y_{i,c}$의 경우 `y_{i,c}`. 이 경우 줄 안에 수학 모드를 원했으므로 시작 및 끝 태그로 하나의 달러 기호만으로 묶습니다.

그리스 문자는 일반적으로 백슬래시가 앞에 붙습니다.\index{방정식!그리스 문자} 일반적인 그리스 문자에는 다음이 포함됩니다: $\alpha$의 경우 `\alpha`, $\beta$의 경우 `\beta`, $\delta$의 경우 `\delta`, $\epsilon$의 경우 `\epsilon`, $\gamma$의 경우 `\gamma`, $\lambda$의 경우 `\lambda`, $\mu$의 경우 `\mu`, $\phi$의 경우 `\phi`, $\pi$의 경우 `\pi`, $\Pi$의 경우 `\Pi`, $\rho$의 경우 `\rho`, $\sigma$의 경우 `\sigma`, $\Sigma$의 경우 `\Sigma`, $\tau$의 경우 `\tau`, $\theta$의 경우 `\theta`.

LaTeX 수학 모드는 문자를 변수로 가정하여 이탤릭체로 만듭니다. 그러나 때로는 "Normal"과 같이 변수가 아니기 때문에 단어가 일반 글꼴로 나타나기를 원할 때가 있습니다. 이 경우 `\mbox{}`로 묶습니다. 예를 들어, $\mbox{Normal}$의 경우 `\mbox{Normal}`.

`\begin{aligned}`와 `\end{aligned}`를 사용하여 여러 줄에 걸쳐 방정식을 정렬합니다. 그러면 정렬할 항목은 앰퍼샌드로 표시됩니다. 다음은 @sec-multilevel-regression-with-post-stratification 에서 추정할 모델입니다.\index{방정식!여러 줄}

``` markdown
$$
\begin{aligned}
y_i|\pi_i & \sim \mbox{Bern}(\pi_i) \\
\mbox{logit}(\pi_i) & = \beta_0+ \alpha_{g[i]}^{\mbox{gender}} + \alpha_{a[i]}^{\mbox{age}} + \alpha_{s[i]}^{\mbox{state}} + \alpha_{e[i]}^{\mbox{edu}} \\
\beta_0 & \sim \mbox{Normal}(0, 2.5)\\
\alpha_{g}^{\mbox{gender}} & \sim \mbox{Normal}(0, 2.5)\mbox{ for }g=1, 2\\
\alpha_{a}^{\mbox{age}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{age}}\right)\mbox{ for }a = 1, 2, \dots, A\\
\alpha_{s}^{\mbox{state}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{state}}\right)\mbox{ for }s = 1, 2, \dots, S\\
\alpha_{e}^{\mbox{edu}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{edu}}\right)\mbox{ for }e = 1, 2, \dots, E\\
\sigma_{\mbox{gender}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{state}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{edu}} & \sim \mbox{Exponential}(1)
\end{aligned}
$$
```

$$
\begin{aligned}
y_i|\pi_i & \sim \mbox{Bern}(\pi_i) \\
\mbox{logit}(\pi_i) & = \beta_0+ \alpha_{g[i]}^{\mbox{gender}} + \alpha_{a[i]}^{\mbox{age}} + \alpha_{s[i]}^{\mbox{state}} + \alpha_{e[i]}^{\mbox{edu}} \\
\beta_0 & \sim \mbox{Normal}(0, 2.5)\\
\alpha_{g}^{\mbox{gender}} & \sim \mbox{Normal}(0, 2.5)\mbox{ for }g=1, 2\\
\alpha_{a}^{\mbox{age}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{age}}\right)\mbox{ for }a = 1, 2, \dots, A\\
\alpha_{s}^{\mbox{state}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{state}}\right)\mbox{ for }s = 1, 2, \dots, S\\
\alpha_{e}^{\mbox{edu}} & \sim \mbox{Normal}\left(0, \sigma^2_{\mbox{edu}}\right)\mbox{ for }e = 1, 2, \dots, E\\
\sigma_{\mbox{gender}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{state}} & \sim \mbox{Exponential}(1)\\
\sigma_{\mbox{edu}} & \sim \mbox{Exponential}(1)
\end{aligned}
$$

마지막으로, 특정 함수는 LaTeX에 내장되어 있습니다. 예를 들어, `\log`를 사용하여 "log"를 적절하게 조판할 수 있습니다.

### 상호 참조 {#sec-quartocrossreferences}

그림, 표, 방정식을 상호 참조하는 것이 유용할 수 있습니다.\index{Quarto!상호 참조} 이렇게 하면 텍스트에서 참조하기가 더 쉬워집니다. 그림의 경우 그림을 생성하거나 포함하는 R 청크의 이름을 참조합니다. 예를 들어, 다음 코드를 고려하십시오.\index{그래프!상호 참조}

:::{.content-visible when-format="pdf"}
```
#| echo: fenced
#| label: fig-theuniquename
#| fig-cap: 지난 2주간의 질병 횟수
#| warning: false

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

그러면 `(@fig-theuniquename)`은 (@fig-theuniquename)을 생성합니다. R 청크의 레이블이 `fig-theuniquename`이기 때문입니다. Quarto가 이것이 그림임을 알 수 있도록 청크 이름 시작 부분에 "fig"를 추가해야 합니다. 그런 다음 캡션을 지정하는 "fig-cap:"을 R 청크에 포함합니다.
:::

:::{.content-visible unless-format="pdf"}
```
#| echo: fenced
#| label: fig-uniquename
#| fig-cap: 1977-1978년 호주 건강 설문조사를 기반으로 한 지난 2주간의 질병 횟수
#| warning: false

data("DoctorVisits", package = "AER")

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count")
```

그러면 `(@fig-uniquename)`은 (@fig-uniquename)을 생성합니다. R 청크의 이름이 `fig-uniquename`이기 때문입니다. Quarto가 이것이 그림임을 알 수 있도록 청크 이름 시작 부분에 "fig"를 추가해야 합니다. 그런 다음 캡션을 지정하는 "fig-cap:"을 R 청크에 포함합니다.
:::



Quarto 문서 내의 R 청크에 `#| layout-ncol: 2`를 추가하여 두 개의 그래프를 나란히 표시할 수 있습니다 ([@fig-doctorgraphsidebyside]).\index{그래프!하위 그림} 여기에서 [@fig-doctorgraphsidebyside-1]은 최소 테마를 사용하고, [@fig-doctorgraphsidebyside-2]는 고전 테마를 사용합니다. 이 둘은 R 청크의 동일한 레이블 `#| label: fig-doctorgraphsidebyside`을 상호 참조하며, R 청크에 추가 옵션 `#| fig-subcap: ["질병 횟수","의사 방문 횟수"]`이 추가되어 하위 캡션을 제공합니다. 텍스트 내에 문자를 추가하는 것은 텍스트에서 사용될 때 레이블 끝에 "-1"과 "-2"를 추가하여 수행됩니다: `([@fig-doctorgraphsidebyside])`, `[@fig-doctorgraphsidebyside-1]`, `[@fig-doctorgraphsidebyside-2]`는 각각 ([@fig-doctorgraphsidebyside]), [@fig-doctorgraphsidebyside-1], [@fig-doctorgraphsidebyside-2]를 생성합니다.

```
#| eval: true
#| warning: false
#| label: fig-doctorgraphsidebyside
#| echo: fenced
#| fig-cap: "두 가지 그래프 변형"
#| fig-subcap: ["질병","의사 방문"]
#| layout-ncol: 2

DoctorVisits |>
  ggplot(aes(x = illness)) +
  geom_histogram(stat = "count") +
  theme_minimal()

DoctorVisits |>
  ggplot(aes(x = visits)) +
  geom_histogram(stat = "count") +
  theme_classic()
```

표를 상호 참조하는 데 유사한 접근 방식을 취할 수 있습니다. 예를 들어, `(@tbl-docvisittable)`은 (@tbl-docvisittable)을 생성합니다. 이 경우 Quarto가 테이블임을 알 수 있도록 레이블 시작 부분에 "tbl"을 지정합니다. 그리고 "tbl-cap:"으로 테이블의 캡션을 지정합니다.\index{표!상호 참조}

```
#| echo: fenced
#| label: tbl-docvisittable
#| tbl-cap: "의사 방문 횟수 분포"

DoctorVisits |>
  count(visits) |>
  tt() |>
  style_tt(j = 2, align = "r") |>
  setNames(c("방문 횟수", "발생 횟수"))
```

마지막으로, 방정식도 상호 참조할 수 있습니다.\index{방정식!상호 참조} 이를 위해 `{#eq-macroidentity}`와 같은 태그를 추가한 다음 참조합니다.

``` markdown
$$
Y = C + I + G + (X - M)
$$ {#eq-gdpidentity}
```

예를 들어, `@eq-gdpidentity`를 사용하여 @eq-gdpidentity 를 생성합니다.

$$
Y = C + I + G + (X - M)
$$ {#eq-gdpidentity}

상호 참조를 사용할 때 레이블은 비교적 간단해야 합니다. 일반적으로 이름을 간단하지만 고유하게 유지하고, 구두점을 피하고, 문자 및 하이픈을 사용하십시오. 밑줄은 오류를 유발할 수 있으므로 사용하지 마십시오.


## R 프로젝트 및 파일 구조

프로젝트\index{R!R 프로젝트}는 소프트웨어 개발에서 널리 사용되며, 특정 프로젝트와 관련된 모든 파일(데이터, 분석, 보고서 등)을 함께 유지하고 서로 관련시키기 위해 존재합니다. (소프트웨어 개발 의미의 "프로젝트"는 프로젝트 관리 의미의 "프로젝트"와 다릅니다.) R 프로젝트는 RStudio에서 만들 수 있습니다. "파일" $\rightarrow$ "새 프로젝트"를 클릭한 다음 "빈 프로젝트"를 선택하고 R 프로젝트 이름을 지정하고 저장할 위치를 결정합니다. 예를 들어, 모성 사망률에 초점을 맞춘 R 프로젝트는 "maternalmortality"라고 불릴 수 있습니다. R 프로젝트를 사용하면 "[다른 컴퓨터나 사용자 간에 그리고 시간이 지남에 따라 신뢰할 수 있고 정중한 동작]을 가능하게 합니다" [@whattheyforgot]. 이는 폴더의 컨텍스트를 더 넓은 존재에서 제거하기 때문입니다. 파일은 컴퓨터의 기반이 아니라 R 프로젝트의 기반과 관련하여 존재합니다.

프로젝트가 생성되면 해당 폴더에 ".RProj" 확장자를 가진 새 파일이 나타납니다. R 프로젝트, Quarto 문서 및 적절한 파일 구조를 가진 폴더의 예는 [여기](https://github.com/RohanAlexander/starter_folder)에서 확인할 수 있습니다. "코드" $\rightarrow$ "ZIP 다운로드"를 통해 다운로드할 수 있습니다.

R 프로젝트를 사용하는 주된 장점은 파일 내에서 자체 포함된 방식으로 파일을 참조할 수 있다는 것입니다. 즉, 다른 사람들이 우리의 작업을 재현하려고 할 때, 모든 파일 참조와 구조를 변경할 필요가 없습니다. 모든 것이 ".Rproj" 파일과 관련하여 참조되기 때문입니다. 예를 들어, `~/Documents/projects/book/data/`에서 CSV를 읽는 대신 `book/data/`에서 읽을 수 있습니다. 다른 사람이 `projects` 폴더를 가지고 있지 않을 수 있으므로 전자는 작동하지 않지만 후자는 작동합니다.

프로젝트 사용은 신뢰할 수 있는 작업에 기대되는 최소한의 재현성 수준을 충족하는 데 필요합니다. `setwd()`와 같은 함수 및 컴퓨터별 파일 경로를 사용하는 것은 작업을 특정 컴퓨터에 부적절하게 바인딩합니다.

폴더를 설정하는 다양한 방법이 있습니다.\index{폴더 구조} @wilsongoodenough 의 변형 중 하나는 위에 링크된 예제 파일 구조에 표시된 것처럼 시작할 때 유용한 경우가 많습니다.

```text
example_project/
├── .gitignore
├── LICENSE.md
├── README.md
├── example_project.Rproj
├── data
│   ├── 00-simulated_data
│   │   ├── simulated_data.csv
│   ├── 01-raw_data
│   │   ├── raw_data.csv
│   ├── 02-analysis_data
│   │   ├── analysis_data.csv
│   │   └── ...
├── model
│   ├── first_model.rds
├── other
│   ├── datasheet
│   │   └── ...
│   ├── literature
│   │   └── ...
│   ├── llm_usage
│   │   └── ...
│   ├── sketches
│   │   └── ...
├── paper
│   ├── paper.pdf
│   ├── paper.qmd
│   ├── references.bib
│   └── ...
├── scripts
│   ├── 00-simulate_data.R
│   ├── 01-test_simulated_data.R
│   ├── 02-download_data.R
│   ├── 03-clean_data.R
│   ├── 04-test_analysis_data.R
│   ├── 05-eda.R
│   ├── 06-model_data.R
│   ├── 07-replication.R
│   └── ...
└── ...
```

여기에는 시뮬레이션된 데이터, 덮어쓰지 않아야 하는 편집되지 않은 데이터 [@wilsongoodenough], 그리고 함께 정리된 분석 데이터가 포함된 `data` 폴더가 있습니다. `model` 폴더에는 저장된 모델 추정치가 포함되어 있습니다. `other` 폴더에는 데이터시트, 문헌, LLM 사용 및 스케치와 같은 측면이 포함되어 있으며, 이는 상황에 따라 유용합니다. `paper` 폴더에는 Quarto 문서와 BibTeX 파일이 포함되어 있습니다. 마지막으로 `scripts`에는 데이터를 시뮬레이션, 다운로드, 테스트 및 분석하는 코드가 포함되어 있습니다.

유용한 다른 측면으로는 프로젝트에 대한 개요 세부 정보를 지정하는 `README.md`와 라이선스가 있습니다. README에 무엇을 넣을지에 대한 예시는 [여기](https://social-science-data-editors.github.io/template_README/)에서 확인할 수 있습니다. 이 프로젝트 골격의 또 다른 유용한 변형은 @GoodResearchCode 에서 제공합니다.



## 버전 관리

이 책에서는 Git과 GitHub\index{GitHub!재현성}\index{Git!재현성}의 조합을 통해 버전 관리\index{재현성!버전 관리}를 구현합니다. 여기에는 다음과 같은 다양한 이유가 있습니다.

1. 코드와 데이터를 더 쉽게 공유하여 작업의 재현성을 향상시킵니다.\index{재현성!GitHub}
2. 작업을 더 쉽게 공유합니다.
3. 체계적인 접근 방식을 장려하여 워크플로우를 개선합니다.\index{GitHub!워크플로우}\index{워크플로우!GitHub}
4. 팀 작업이 더 쉬워집니다.\index{GitHub!팀}

Git은 흥미로운 역사를 가진 버전 관리 시스템입니다 [@githistory]. 버전 관리를 시작하는 일반적인 방법은 "first_go.R", "first_go-fixed.R", "first_go-fixed-with-mons-edits.R"과 같이 하나의 파일에 여러 복사본을 두는 것입니다. 그러나 이것은 곧 번거로워집니다. 종종 곧 날짜를 사용하게 됩니다. 예를 들어, "2022-01-01-analysis.R", "2022-01-02-analysis.R", "2022-01-03-analysis.R" 등입니다. 이것은 기록을 유지하지만, 어떤 변경이 언제 이루어졌는지 기억하기 어렵기 때문에 다시 돌아가야 할 때 검색하기 어려울 수 있습니다. 어쨌든, 정기적으로 작업하는 프로젝트에는 빠르게 다루기 힘들어집니다.

대신 Git을 사용하여 파일의 한 버전을 가질 수 있습니다. Git은 해당 파일에 대한 변경 기록과 특정 시점의 해당 파일 스냅샷을 유지합니다. Git이 스냅샷을 찍는 시점을 결정합니다. 또한 이 스냅샷과 마지막 스냅샷 사이에 무엇이 변경되었는지 설명하는 메시지를 포함합니다. 이런 식으로 파일의 버전은 항상 하나뿐이며, 기록을 더 쉽게 검색할 수 있습니다.

한 가지 복잡한 점은 Git이 소프트웨어 개발자 팀을 위해 설계되었다는 것입니다. 따라서 작동하더라도 비개발자에게는 다소 다루기 힘들 수 있습니다. 그럼에도 불구하고 Git은 데이터 과학에 유용하게 적용되었으며, 유일한 협력자가 미래의 자신일지라도 마찬가지입니다 [@Bryan2018].\index{데이터 과학!Git}\index{Git!데이터 과학}

GitHub, GitLab 및 기타 여러 회사는 Git을 기반으로 하는 사용하기 쉬운 서비스를 제공합니다. 장단점이 있지만, 여기서는 GitHub를 소개합니다. 왜냐하면 GitHub가 지배적인 플랫폼이기 때문입니다 [@eghbal2020working, p. 21]. Git과 GitHub는 Posit Cloud에 내장되어 있어 로컬 설치에 문제가 있는 경우 좋은 옵션을 제공합니다. Git의 초기 어려운 측면 중 하나는 용어입니다.\index{Git!용어} 폴더는 "repo"라고 불립니다. 스냅샷을 만드는 것은 "commit"이라고 불립니다. 결국 익숙해지겠지만, 처음에는 혼란스러운 것이 정상입니다. @happygit 은 Git 및 GitHub 설정 및 사용에 특히 유용합니다.



### Git

먼저 Git\index{Git!설정}이 설치되어 있는지 확인해야 합니다. RStudio를 열고 터미널로 이동하여 다음을 입력한 다음 Enter/Return을 누르십시오.

```bash
#| eval: false
#| echo: true

git --version
```

버전 번호가 나오면 완료된 것입니다 (@fig-gitone).

:::{#fig-grits layout-ncol=1}

![RStudio에서 Git이 설치되어 있는지 확인하기 위해 터미널 사용](figures/03-git-setup-01.png){#fig-gitone}

![RStudio에서 Git에 사용자 이름과 이메일 주소 추가](figures/03-git-setup-02.png){#fig-gitone-setup}

Git 설정에 관련된 단계 개요
:::


Git은 Posit Cloud\index{Posit Cloud!Git}\index{Git!Posit Cloud}에 사전 설치되어 있으며, Mac에는 사전 설치되어 있어야 하고, Windows에는 사전 설치되어 있을 수 있습니다. 응답으로 버전 번호가 나오지 않으면 설치해야 합니다. 이를 위해 @happygit [5장]의 운영 체제별 지침을 따르십시오.

Git이 설치되면 사용자 이름과 이메일을 알려야 합니다. Git은 스냅샷을 찍을 때마다, 또는 Git의 언어로 커밋을 할 때마다 이 정보를 추가하기 때문에 이 작업을 수행해야 합니다.

다시 터미널에서 다음을 입력하고 세부 정보를 자신의 것으로 바꾼 다음 각 줄 뒤에 "enter/return"을 누르십시오.

```bash
#| eval: false
#| echo: true

git config --global user.name "로한 알렉산더"
git config --global user.email "rohan.alexander@utoronto.ca"
git config --global --list
```

이 설정이 제대로 완료되면 "user.name" 및 "user.email"에 입력한 값이 마지막 줄 뒤에 반환됩니다 (@fig-gitone-setup).

이러한 세부 정보(사용자 이름 및 이메일 주소)는 공개됩니다. 필요한 경우 이메일 주소를 숨기는 다양한 방법이 있으며, GitHub는 이에 대한 지침을 제공합니다. @happygit [7장]은 이 단계에 대한 더 자세한 지침과 문제 해결 가이드를 제공합니다.


### GitHub

이제 Git이 설정되었으므로 GitHub\index{GitHub}를 설정해야 합니다. @sec-fire-hose 에서 GitHub 계정을 만들었으며, 여기에서 다시 사용합니다. `github.com`에 로그인한 후 먼저 새 폴더를 만들어야 합니다. Git에서는 이를 "repo"라고 부릅니다. 오른쪽 상단에서 "+"를 찾은 다음 "새 저장소"를 선택합니다 (@fig-githubtwo).

:::{#fig-gritshub layout-nrow=3}

![새 저장소 생성 프로세스 시작](figures/github_2.png){#fig-githubtwo}

![새 저장소의 URL 복사](figures/github_4.png){#fig-githubfour}

![Posit Cloud에 프로젝트 추가](figures/03-github-new-project.png){#fig-githubnewproject}

![PAT 생성](figures/04-githubpat.png){#fig-githubpat}

![커밋할 파일 추가](figures/03-github-add.png){#fig-githubadd}

![커밋 만들기](figures/03-github-commit.png){#fig-githubcommit}

GitHub 설정에 관련된 단계 개요
:::

이 시점에서 저장소에 적절한 이름을 추가할 수 있습니다. 지금은 "공개"로 두십시오. 나중에 언제든지 삭제할 수 있기 때문입니다. 그리고 "README로 이 저장소 초기화" 상자를 선택하십시오. ".gitignore 추가"를 R로 변경하십시오. 그런 다음 "저장소 생성"을 클릭하십시오.

그러면 상당히 비어 있는 화면으로 이동하지만, 필요한 세부 정보(URL)는 녹색 "복제 또는 다운로드" 버튼에 있으며, 클립보드를 클릭하여 복사할 수 있습니다 (@fig-githubfour).

이제 RStudio\index{R!RStudio}로 돌아와 Posit Cloud\index{Posit Cloud}에서 "Git 저장소에서 새 프로젝트"를 사용하여 새 프로젝트를 만듭니다. 방금 복사한 URL을 요청할 것입니다 (@fig-githubnewproject). 로컬 컴퓨터를 사용하는 경우 이 단계는 메뉴를 통해 수행됩니다: "파일" $\rightarrow$ "새 프로젝트..." $\rightarrow$ "버전 제어" $\rightarrow$ "Git"을 선택한 다음 URL을 붙여넣고 폴더에 의미 있는 이름을 지정하고 "새 세션에서 열기"를 선택한 다음 "프로젝트 생성"을 클릭합니다.

이 시점에서 사용할 수 있는 새 폴더가 생성되었습니다. GitHub로 다시 푸시할 수 있어야 하며, 이를 위해 RStudio 작업 공간을 GitHub\index{GitHub} 계정과 연결하려면 개인 액세스 토큰(PAT)을 사용해야 합니다. 이를 위해 `usethis`와 `gitcreds`를 사용합니다. 이들은 각각 반복 작업을 자동화하는 패키지와 GitHub로 인증하는 패키지입니다. PAT를 만들려면 브라우저에서 GitHub에 로그인한 상태에서 `usethis`를 설치하고 로드한 후 R 세션에서 `create_github_token()`을 실행합니다. GitHub는 다양한 옵션이 채워진 브라우저에서 열립니다 (@fig-githubpat). "Note"를 "PAT for RStudio"와 같이 정보가 담긴 이름으로 바꾸는 것이 유용할 수 있습니다. 그런 다음 "토큰 생성"을 클릭합니다.

이 토큰을 복사할 기회는 한 번뿐이며, 실수를 하면 새 토큰을 생성해야 합니다. PAT\index{개인 액세스 토큰!GitHub}를 R 스크립트나 Quarto 문서에 포함하지 마십시오. 대신 `gitcreds`를 설치하고 로드한 후 `gitcreds_set()`를 실행하면 콘솔에서 PAT를 추가하라는 메시지가 나타납니다.

활발하게 작업 중인 프로젝트에 GitHub\index{GitHub}를 사용하려면 다음 절차를 따릅니다.

1. 가장 먼저 해야 할 일은 거의 항상 "pull"을 사용하여 변경 사항을 가져오는 것입니다. 이렇게 하려면 RStudio의 Git 창을 열고 파란색 아래쪽 화살표를 클릭합니다.\index{Git!RStudio} 이렇게 하면 GitHub에 있는 폴더의 변경 사항이 우리 자신의 폴더 버전으로 가져와집니다.
2. 그런 다음 폴더의 복사본에 변경 사항을 적용할 수 있습니다. 예를 들어, README를 업데이트한 다음 평소처럼 저장할 수 있습니다.
3. 이 작업이 완료되면 추가, 커밋 및 푸시해야 합니다. RStudio의 Git 창에서 추가할 파일을 선택합니다. 이렇게 하면 파일이 스테이징 영역에 추가됩니다. 그런 다음 "커밋"을 클릭합니다 (@fig-githubadd). 새 창이 열립니다. 변경 사항에 대한 정보가 담긴 메시지를 추가한 다음 해당 새 창에서 "커밋"을 클릭합니다 (@fig-githubcommit). 마지막으로 "푸시"를 클릭하여 변경 사항을 GitHub로 보냅니다.

Git과 GitHub에는 몇 가지 일반적인 문제점이 있습니다. 버전 관리에 익숙하지 않은 경우 정기적으로 커밋하고 푸시하는 것이 좋습니다. 이렇게 하면 필요한 경우 다시 돌아갈 수 있는 스냅샷 수가 늘어납니다. 모든 커밋에는 정보가 담긴 커밋 메시지가 있어야 합니다. 버전 관리에 익숙하지 않은 경우 좋은 커밋 메시지는 변경 사항에 대한 짧은 요약, 빈 줄, 그리고 변경 사항이 무엇이며 왜 이루어졌는지에 대한 설명을 포함해야 합니다. 예를 들어, 커밋이 논문에 그래프를 추가하는 경우 커밋 메시지는 다음과 같을 수 있습니다.

```
그래프 추가

실업률 및 인플레이션 그래프가 데이터 섹션에 추가되었습니다.
```

전반적인 품질과 커밋 동작 사이에 관계가 있다는 증거가 있습니다 [@sprint2019mining]. 경험이 쌓이면 커밋 메시지가 프로젝트의 일종의 일지 역할을 할 것입니다. 그러나 가장 중요한 것은 정기적으로 커밋하는 것입니다.

Git과 GitHub는 데이터 과학자보다는 소프트웨어 개발자를 위해 설계되었습니다. GitHub는 고려할 파일의 크기를 100MB로 제한하며, 50MB도 경고를 표시할 수 있습니다.\index{GitHub!파일 크기} 데이터 과학 프로젝트에는 이보다 큰 데이터 세트가 정기적으로 포함됩니다. @sec-store-and-share 에서는 프로젝트가 완료되었을 때 특히 유용한 데이터 예금 사용에 대해 논의하지만, 프로젝트를 활발하게 작업할 때는 Git과 GitHub에 관한 한 큰 데이터 파일을 무시하는 것이 유용할 수 있습니다. 이를 위해 ".gitignore" 파일을 사용하며, Git을 사용하여 추적하지 않을 모든 파일을 나열합니다. [예제 폴더](https://github.com/RohanAlexander/starter_folder)에는 ".gitignore" 파일이 포함되어 있습니다. 그리고 `usethis`에서 `git_vaccinate()`를 실행하는 것이 도움이 될 수 있습니다. 이렇게 하면 프로젝트별로 수행하는 것을 잊어버린 경우 다양한 파일을 전역 ".gitignore" 파일에 추가합니다. Mac 사용자는 ".DS_Store" 파일이 무시된다는 점이 유용할 것입니다.

RStudio의 Git 창을 사용하여 터미널을 사용할 필요가 없었지만, GitHub로 이동하여 새 프로젝트를 설정할 필요는 없었습니다. Git과 GitHub를 설정했으므로 `usethis`를 사용하여 워크플로우의 이 측면을 더욱 개선할 수 있습니다.

먼저 `usethis`의 `git_sitrep()`으로 Git이 설정되었는지 확인합니다. 그러면 사용자 이름과 이메일에 대한 정보가 인쇄되어야 합니다. 필요한 경우 `use_git_config()`를 사용하여 이러한 세부 정보를 업데이트할 수 있습니다.

```
#| eval: false
#| include: true

use_git_config(
  user.name = "로한 알렉산더",
  user.email = "rohan.alexander@utoronto.ca"
)
```

GitHub에서 새 프로젝트를 시작한 다음 로컬로 추가하는 대신, 이제 `use_git()`을 사용하여 프로젝트를 시작하고 파일을 커밋할 수 있습니다. 커밋한 후 `use_github()`를 사용하여 GitHub로 푸시하면 GitHub에도 폴더가 생성됩니다.

Git과 GitHub에 위협을 느끼는 것은 정상입니다. 많은 데이터 과학자들은 그것을 사용하는 방법을 조금만 알고 있으며, 그것으로 충분합니다. 필요한 경우 최근 스냅샷을 가질 수 있도록 정기적으로 푸시하십시오.

### Git 충돌

*파우스트 박사*는 크리스토퍼 말로우의 16세기 희곡입니다. 흥미롭게도 두 가지 버전이 있으며, 말로우가 실제로 "그" 버전으로 의도한 것이 어떤 버전인지 아무도 모릅니다. 정확히 세는 방식에 따라 @faustus1604 에는 약 2,048줄이 있고, @faustus1616 에는 약 2,852줄이 있습니다. 줄 안에서도 변경 사항이 있습니다 (@fig-githubconflict). 저자가 오래 전에 사망했기 때문에 인류는 단순히 두 가지 버전이 존재하는 이상한 상황에 놓여 있습니다. 말로우가 Git을 가지고 있었다면 이런 일은 일어나지 않았을 것입니다!

:::{#fig-githubconflict layout-nrow=1}

![1604년 버전의 처음 몇 줄](figures/03-faustus1604.png){#fig-githubconflictone}

![1616년 버전의 처음 몇 줄](figures/03-faustus1616.png){#fig-githubconflicttwo}

파우스트 박사의 1604년 버전과 1616년 버전 간의 차이점 표시
:::

Git과 GitHub를 사용할 때 우리는 주기적으로 버전을 체크인합니다. 그러나 동일한 저장소에서 작업하는 두 사람이 동일한 줄에 변경 사항을 적용하는 코드를 체크인하려고 하면 어떻게 될까요? Git은 병합 충돌을 설정하고, 충돌을 발생시킨 사람, 즉 두 번째 커밋을 한 사람이 이를 해결해야 합니다.

Git은 파일에 두 가지를 모두 표시하고 시작 부분에 `<<<<<<< HEAD`, 충돌하는 변경 사항을 구분하는 `=======`, 그리고 끝과 어떤 브랜치가 충돌을 생성하는지 보여주는 `>>>>>>> new_branch`와 같은 식별 마커를 추가하여 충돌하는 줄을 식별합니다.

```bash
#| eval: false
#| echo: true

<<<<<<< HEAD
일부 내용
=======
일부 충돌 내용
>>>>>>> new_branch
```

충돌을 해결하려는 사람의 임무는 어떤 내용을 유지할지 선택하는 것입니다. 파일을 편집하고 저장한 다음 일반적인 방식으로 추가하고 커밋합니다.



## R 실습

### 오류 처리 {#sec-dealingwitherrors}

> 프로그래밍을 하다 보면 결국 코드가 깨질 것입니다. 결국이라고 말하는 것은 아마 하루에 10번 또는 20번 정도를 의미합니다.
>
> @sharlatalks

R을 사용하거나 어떤 프로그래밍 언어를 사용하든 모든 사람은 어느 시점에서 문제를 겪습니다. 이것은 정상입니다. 프로그래밍은 어렵습니다. 어느 시점에서 코드가 실행되지 않거나 오류가 발생할 것입니다.\index{R!오류} 이것은 모든 사람에게 일어나는 일입니다. 좌절하는 것은 흔한 일이지만, 앞으로 나아가기 위해 문제를 해결하기 위한 전략을 개발합니다.\index{도움말!전략}

1. 오류 메시지가 나타나면 때로는 유용할 것입니다. 유용한 내용이 있는지 주의 깊게 읽어보십시오.
2. 오류 메시지를 검색해 보십시오.\index{Google!도움 받기} 결과를 더 적절하게 만들려면 검색에 "tidyverse" 또는 "in R"을 포함하는 것이 유용할 수 있습니다. 때로는 Stack Overflow 결과가 유용할 수 있습니다.
3. 함수 앞에 "?"를 붙여 함수의 도움말 파일을 살펴보십시오. 예를 들어, `?pivot_wider()`와 같이 말입니다. 일반적인 문제는 약간 잘못된 인수 이름이나 형식을 사용하는 것입니다. 예를 들어, 실수로 객체 이름 대신 문자열을 포함하는 경우입니다.
4. 오류가 발생하는 위치를 확인하고 오류가 해결될 때까지 코드를 제거하거나 주석 처리한 다음 천천히 코드를 다시 추가하십시오.
5. `class()`를 사용하여 객체의 클래스를 확인하십시오. 예를 들어, `class(data_set$data_column)`과 같이 말입니다. 예상한 것인지 확인하십시오.\index{도움말!클래스 확인}
6. R을 다시 시작하십시오: "세션" $\rightarrow$ "R 다시 시작 및 출력 지우기". 그런 다음 모든 것을 다시 로드하십시오.
7. 컴퓨터를 다시 시작하십시오.
8. 오류 메시지 대신 수행하려는 작업을 검색하십시오. 결과를 더 적절하게 만들려면 검색에 "tidyverse" 또는 "in R"을 포함해야 합니다. 예를 들어, "ggplot을 사용하여 R에서 그래프 PDF 저장"과 같이 말입니다. 때로는 관련 블로그 게시물이나 Stack Overflow 답변이 도움이 될 것입니다.
9. 문제를 격리하고 다른 사람들이 도움을 줄 수 있도록 작고 자체 포함된 재현 가능한 예제 "reprex"를 만드십시오.\index{reprex}\index{도움말!재현 가능한 예제}
10. Quarto 문서에서 작업하는 경우 청크 옵션에 레이블을 포함하여 실수가 발생할 수 있는 위치를 더 쉽게 찾을 수 있도록 하십시오.

더 일반적으로, 항상 가능하지는 않지만, 휴식을 취하고 다음 날 다시 돌아오는 것이 거의 항상 도움이 됩니다.


### 재현 가능한 예제 {#sec-omgpleasemakeareprexplease}

> 아무도 당신에게 조언하거나 도울 수 없습니다. 아무도. 당신이 해야 할 일은 단 하나뿐입니다. 자신 안으로 들어가십시오.
>
> @릴케

도움을 요청하는 것은 다른 기술과 마찬가지로 기술입니다.\index{도움말!재현 가능한 예제} 연습을 통해 더 잘하게 됩니다. "이것은 작동하지 않습니다", "모든 것을 시도했습니다", "당신의 코드는 작동하지 않습니다", 또는 "여기 오류 메시지가 있습니다. 어떻게 해야 합니까?"라고 말하지 않도록 노력하는 것이 중요합니다. 일반적으로 이러한 의견을 기반으로 도움을 줄 수는 없습니다. 너무 많은 가능한 문제가 있기 때문입니다. 다른 사람들이 당신을 돕기 쉽게 만들어야 합니다. 여기에는 몇 가지 단계가 포함됩니다.\index{도움말!요청하기}

1. 데이터와 코드의 작고 자체 포함된 예제를 제공하고, 무엇이 잘못되었는지 자세히 설명하십시오.
2. 지금까지 시도한 내용을 문서화하십시오. 어떤 Stack Overflow 및 Posit Forum 게시물을 보았는지, 그리고 왜 원하는 것이 아닌지 포함하십시오.
3. 원하는 결과에 대해 명확하게 설명하십시오.

최소한의 재현 가능한 예제("reprex")를 만드는 것으로 시작하십시오.\index{reprex} 이것은 오류를 재현하는 데 필요한 것만 포함하는 코드입니다. 즉, 코드는 오류를 재현하지만 더 작고 간단한 버전일 가능성이 높습니다.

때로는 이 과정에서 문제를 해결할 수 있습니다. 그렇지 않다면, 다른 사람이 도움을 줄 수 있는 기회를 제공합니다. 다른 사람이 이전에 해결하지 못한 문제가 당신에게 있을 가능성은 거의 없습니다. 주요 어려움은 당신이 하고 싶은 것과 일어나고 있는 일을 다른 사람들이 모두 인식할 수 있는 방식으로 전달하는 것입니다. 끈기를 기르는 것이 중요합니다.

재현 가능한 예제를 개발하는 데 `reprex`가 특히 유용합니다. 설치 후 다음을 수행합니다.

1. `reprex` 패키지를 로드합니다: `library(reprex)`.
2. 문제가 있는 코드를 강조 표시하고 복사합니다.
3. 콘솔에서 `reprex()`를 실행합니다.

코드가 자체 포함되어 있으면 뷰어에 미리 보기가 표시됩니다. 그렇지 않으면 오류가 발생하며, 코드를 자체 포함되도록 다시 작성해야 합니다.

오류를 재현하기 위해 데이터가 필요한 경우 R에 내장된 데이터를 사용해야 합니다. `library(help = "datasets")`를 사용하여 R에 내장된 많은 데이터 세트를 볼 수 있습니다. 그러나 가능하다면 `mtcars` 또는 `faithful`과 같은 일반적인 옵션을 사용해야 합니다. @sec-fire-hose에서 소개된 GitHub Gist와 reprex를 결합하면 다른 사람이 당신을 도울 수 있는 가능성이 높아집니다.


### 사고방식

> 당신이 어떤 IDE에서 개발하든, 어떤 도구를 사용하여 작업을 수행하든, 당신은 실제적이고 유효하며 *유능한* 사용자이자 프로그래머입니다.
>
> 문을 부수고 들어갑시다. 모두를 위한 충분한 공간이 있습니다.
>
> Sharla Gelfand, 2020년 3월 10일.

코드를 작성한다면, 당신은 프로그래머입니다. 어떻게 하든, 무엇을 위해 사용하든, 누구든 상관없이 말입니다.\index{코드!특성} 그러나 위대한 프로그래머들이 공통적으로 가지고 있는 몇 가지 특성이 있습니다.

- **집중:** 종종 "R 배우기"와 같은 목표는 문제가 되는 경향이 있습니다. 왜냐하면 그것에는 실제 끝점이 없기 때문입니다. "ggplot2"를 사용하여 2022년 호주 선거에 대한 히스토그램을 만드는 것과 같이 더 작고 구체적인 목표를 갖는 것이 더 효율적인 경향이 있습니다. 이것은 몇 시간 안에 집중하고 달성할 수 있는 것입니다. "R을 배우고 싶다"와 같이 모호한 목표의 문제는 곁가지로 빠지기 쉽고 도움을 받기 어렵다는 것입니다. 이것은 사기를 저하시키고 사람들이 너무 일찍 포기하게 만들 수 있습니다.
- **호기심:** "시도해 보는 것"은 거의 항상 유용합니다. 즉, 확실하지 않다면 그냥 시도해 보십시오. 일반적으로 최악의 경우 시간을 낭비하는 것입니다. 돌이킬 수 없을 정도로 무언가를 망가뜨리는 경우는 거의 없습니다. 예를 들어, 데이터프레임 대신 벡터를 `ggplot()`에 전달하면 어떻게 되는지 알고 싶다면 시도해 보십시오.
- **실용적:** 동시에 합리적인 범위 내에서 유지하고 한 번에 작은 변경만 하는 것이 유용할 수 있습니다. 예를 들어, 회귀 분석을 실행하고 싶고 `lm()` 대신 `rstanarm`을 사용할 가능성에 대해 궁금하다고 가정해 봅시다. 진행하는 실용적인 방법은 처음에 `rstanarm`의 한 측면을 사용한 다음 다음에 다른 변경을 하는 것입니다.
- **끈기:** 다시 말하지만, 이것은 균형 잡힌 행동입니다. 모든 프로젝트에는 예상치 못한 문제와 이슈가 발생합니다. 한편으로는 이러한 문제에도 불구하고 인내하는 것이 좋은 경향입니다. 그러나 다른 한편으로는 돌파구가 불가능해 보인다면 때로는 무언가를 포기할 준비가 되어 있어야 합니다. 멘토는 합리적인 것을 더 잘 판단하는 경향이 있으므로 유용할 수 있습니다.
- **계획:** 수행할 작업을 과도하게 계획하는 것이 거의 항상 유용합니다. 예를 들어, 일부 데이터의 히스토그램을 만들고 싶을 수 있습니다. 필요한 단계를 계획하고 각 단계가 어떻게 구현될 수 있는지 스케치해야 합니다. 예를 들어, 첫 번째 단계는 데이터를 가져오는 것입니다. 어떤 패키지가 유용할 수 있습니까? 데이터는 어디에 있을 수 있습니까? 데이터가 거기에 없으면 백업 계획은 무엇입니까?
- **완벽보다 완료:** 우리 모두는 다양한 완벽주의적 경향을 가지고 있지만, 처음에는 어느 정도 그것들을 끄는 것이 유용할 수 있습니다. 처음에는 작동하는 코드를 작성하는 것에만 신경 쓰십시오. 언제든지 돌아와서 측면을 개선할 수 있습니다. 그러나 실제로 출시하는 것이 중요합니다. 작업을 완료하는 못생긴 코드가 결코 완성되지 않는 아름다운 코드보다 낫습니다.


### 코드 주석 및 스타일

코드는 주석 처리되어야 합니다.\index{코드!주석} 주석은 특정 코드가 작성된 이유와 일반적인 대안이 선택되지 않은 이유에 중점을 두어야 합니다. 실제로 코드를 작성하기 전에 주석을 작성하여 무엇을 하고 싶은지, 왜 하고 싶은지 설명한 다음 코드를 작성하는 것이 좋습니다 [@refactoringbook, p. 59].

특히 R에서는 코드를 작성하는 한 가지 방법만 있는 것은 아닙니다. 그러나 혼자 작업하더라도 더 쉽게 작업할 수 있는 몇 가지 일반적인 지침이 있습니다. 대부분의 프로젝트는 시간이 지남에 따라 진화하며, 코드 주석의 한 가지 목적은 미래의 당신이 수행된 작업과 특정 결정이 내려진 이유를 다시 추적할 수 있도록 하는 것입니다 [@bowers2016improve].

R 스크립트의 주석은 # 기호를 포함하여 추가할 수 있습니다. (#의 동작은 Quarto 문서의 R 청크 내부 줄과 R 청크 외부 줄에서 헤더 수준을 설정하는 것과 다릅니다.) 줄 시작 부분에 주석을 넣을 필요는 없으며, 중간에 넣을 수도 있습니다. 일반적으로 코드의 모든 측면이 무엇을 하는지 주석을 달 필요는 없지만, 명확하지 않은 부분은 주석을 달아야 합니다. 예를 들어, 어떤 값을 읽어들이는 경우 어디에서 왔는지 주석을 달고 싶을 수 있습니다.

무엇을 하고 있는지 주석을 달아야 합니다 [@tidyversestyleguide]. 무엇을 달성하려고 합니까? 이상한 점을 설명하기 위해 주석을 달아야 합니다. 예를 들어, 특정 행, 예를 들어 27번 행을 제거하는 경우 왜 그 행을 제거하는지 설명해야 합니다. 그 순간에는 명확해 보일 수 있지만, 미래의 당신은 기억하지 못할 것입니다.

코드를 섹션으로 나누어야 합니다. 예를 들어, 작업 공간 설정, 데이터 세트 읽기, 데이터 세트 조작 및 정리, 데이터 세트 분석, 마지막으로 표 및 그림 생성 등이 있습니다. 각 섹션은 무엇이 진행되고 있는지 설명하는 주석으로 구분되어야 하며, 길이에 따라 별도의 파일로 나눌 수도 있습니다.

또한 각 파일의 상단에는 파일의 목적, 전제 조건 또는 종속성, 날짜, 저자 및 연락처 정보, 마지막으로 위험 요소 또는 할 일과 같은 기본 정보를 기록하는 것이 중요합니다.

R 스크립트에는 서문과 명확한 섹션 구분이 있어야 합니다.

```
#### 서문 ####
# 목적: 이 스크립트가 하는 일에 대한 간략한 문장
# 저자: 당신의 이름
# 날짜: 작성된 날짜
# 연락처: 이메일 추가
# 라이선스: 코드가 어떻게 사용될 수 있는지 생각하십시오.
# 전제 조건:
# - 일부 데이터 또는 다른 스크립트가 실행되어야 할 수도 있습니까?


#### 작업 공간 설정 ####
# install.packages 줄을 유지하지 마십시오. 필요한 경우 주석 처리하십시오.
# 패키지 로드
library(tidyverse)

# 편집되지 않은 데이터 읽기.
raw_data <- read_csv("inputs/data/unedited_data.csv")


#### 다음 섹션 ####
...

```

마지막으로, 코드가 작동하기 위해 사용자가 코드를 주석 처리하거나 주석 해제하는 것, 또는 디렉토리 지정과 같은 다른 수동 단계에 의존하지 않도록 노력하십시오. 이렇게 하면 자동화된 코드 검사 및 테스트를 사용할 수 없게 됩니다.

이 모든 것은 시간이 걸립니다. 대략적인 경험 법칙으로, 코드를 작성하는 데 걸린 시간만큼 주석을 달고 코드를 개선하는 데 시간을 할애해야 합니다. 잘 주석 처리된 코드의 예로는 @AhadyDolatsara2021 및 @burton2021reconsidering 이 있습니다.


### 테스트

테스트\index{테스트}는 코드 전체에 작성되어야 하며, 끝에서 한꺼번에 작성하는 것이 아니라 진행하면서 작성해야 합니다. 이렇게 하면 속도가 느려질 것입니다. 그러나 생각하는 데 도움이 되고 실수를 수정하는 데 도움이 되어 코드를 더 좋게 만들고 전반적인 생산성을 향상시킬 것입니다. 테스트 없는 코드는 의심스럽게 보아야 합니다. R 패키지 [@Vidoni2021]의 테스트 관행은 물론 R 코드 전반에 걸쳐 개선의 여지가 있습니다.

다른 사람들, 그리고 이상적으로는 자동화된 프로세스가 코드를 테스트해야 하는 필요성은 우리가 재현성을 강조하는 이유 중 하나입니다. 또한 파일 경로를 하드코딩하지 않고, 프로젝트를 사용하고, 파일 이름에 공백을 두지 않는 것과 같은 작은 측면을 강조하는 이유이기도 합니다.\index{재현성}

완전하고 일반적인 테스트 스위트를 정의하기는 어렵지만, 일반적으로 다음을 테스트하려고 합니다.

1) 경계 조건,
2) 클래스,
3) 누락된 데이터,
4) 관측치 및 변수의 수,
5) 중복,
6) 회귀 결과.

이 모든 것을 처음에는 시뮬레이션된 데이터에서 수행한 다음 실제 데이터로 이동합니다. 이는 아폴로 프로그램 중 테스트의 진화를 반영합니다. 처음에는 요구 사항에 대한 기대를 기반으로 테스트가 수행되었으며, 이러한 테스트는 나중에 실제 발사 측정값을 고려하도록 업데이트되었습니다 [@testingforsuccess, p. 21]. 무한한 수의 테스트를 작성할 수 있지만, 많은 생각 없는 테스트보다 적은 수의 고품질 테스트가 더 좋습니다.

한 가지 유형의 테스트는 "어설션"입니다.\index{테스트!어설션} 어설션은 코드 전체에 작성되어 무언가가 참인지 확인하고 그렇지 않으면 코드 실행을 중지합니다 [@researchsoftware, p. 272]. 예를 들어, 변수가 숫자여야 한다고 어설션할 수 있습니다. 이 어설션에 대해 테스트되었고 문자임이 밝혀지면 테스트가 실패하고 스크립트 실행이 중지됩니다. 데이터 과학의 어설션 테스트는 일반적으로 데이터 정리 및 준비 스크립트에서 사용됩니다. @sec-clean-and-prepare 에서 이에 대해 더 자세히 설명합니다. 단위 테스트는 코드의 완전한 측면을 확인합니다 [@researchsoftware, p. 274].\index{테스트!단위 테스트} 모델링을 고려할 때 @sec-its-just-a-linear-model 에서 더 자세히 다룰 것입니다.



## 효율성

일반적으로\index{효율성!코드} 이 책에서는 무언가를 완료하는 데만 관심이 있습니다. 가장 좋거나 가장 효율적인 방법으로 완료하는 데는 반드시 관심이 없습니다. 왜냐하면 대부분의 경우 그것에 대해 걱정하는 것은 시간 낭비이기 때문입니다. 대부분의 경우 클라우드에 푸시하고 합리적인 시간 동안 실행되도록 한 다음 파이프라인의 다른 측면에 대해 걱정하는 것이 더 좋습니다. 그러나 그것은 결국 불가능해집니다. 특정 시점에서 (그리고 이는 상황에 따라 다릅니다) 효율성이 중요해집니다. 결국 못생기거나 느린 코드, 그리고 특정 방식으로 작업을 수행하려는 독단적인 고집은 영향을 미칩니다. 그리고 그 시점에서 효율성을 보장하기 위해 새로운 접근 방식에 개방적이어야 합니다. 명백한 성능 향상을 위한 가장 일반적인 영역은 거의 없습니다. 대신 측정, 평가 및 사고 능력을 개발하는 것이 중요합니다.

코드 효율성을 향상시키는 가장 좋은 방법 중 하나는 다른 사람의 시선을 빌릴 수 있도록 준비하는 것입니다.\index{동료 검토}\index{효율성!공유를 통해} 그들의 시간을 최대한 활용하려면 코드를 읽기 쉽게 만드는 것이 중요합니다. 그래서 "코드 린팅"과 "스타일링"으로 시작합니다. 이것은 코드 속도를 높이는 것이 아니라, 다른 사람이 코드를 보거나 우리가 다시 방문할 때 더 효율적으로 만듭니다. 이를 통해 공식적인 코드 검토 및 리팩토링이 가능해집니다. 리팩토링은 코드를 더 좋게 만들기 위해 코드를 다시 작성하는 것이지만, 코드가 하는 일을 변경하지는 않습니다 (동일한 작업을 다른 방식으로 수행합니다). 그런 다음 실행 시간 측정으로 전환하고 병렬 처리를 도입하여 컴퓨터가 여러 프로세스에 대한 코드를 동시에 실행할 수 있도록 합니다.


### 코드 환경 공유

:::{.content-visible when-format="pdf"}
우리는 코드 공유의 필요성에 대해 길게 논의했으며, GitHub를 사용하여 이에 대한 접근 방식을 제시했습니다.\index{재현성}\index{효율성!재현성} 그리고 @sec-store-and-share 에서는 데이터 공유에 대해 논의할 것입니다. 그러나 다른 사람들이 우리의 코드를 실행할 수 있도록 하는 또 다른 요구 사항이 있습니다. @sec-fire-hose 에서 R 자체와 R 패키지가 새로운 기능이 개발되고 오류가 수정되며 기타 일반적인 개선 사항이 있을 때마다 때때로 업데이트된다는 점을 논의했습니다. ["R 필수 사항" 온라인 부록](https://tellingstorieswithdata.com/20-r_essentials.html)은 `tidyverse`의 한 가지 장점이 더 구체적이기 때문에 기본 R보다 더 빠르게 업데이트될 수 있다는 점을 설명합니다. 그러나 이는 우리가 사용하는 모든 코드와 데이터를 공유하더라도 사용 가능한 소프트웨어 버전이 오류를 유발할 수 있음을 의미할 수 있습니다.
:::

:::{.content-visible unless-format="pdf"}
우리는 코드 공유의 필요성에 대해 길게 논의했으며, GitHub를 사용하여 이에 대한 접근 방식을 제시했습니다.\index{재현성}\index{효율성!재현성} 그리고 @sec-store-and-share 에서는 데이터 공유에 대해 논의할 것입니다. 그러나 다른 사람들이 우리의 코드를 실행할 수 있도록 하는 또 다른 요구 사항이 있습니다. @sec-fire-hose 에서 R 자체와 R 패키지가 새로운 기능이 개발되고 오류가 수정되며 기타 일반적인 개선 사항이 있을 때마다 때때로 업데이트된다는 점을 논의했습니다. [온라인 부록 -@sec-r-essentials]은 `tidyverse`의 한 가지 장점이 더 구체적이기 때문에 기본 R보다 더 빠르게 업데이트될 수 있다는 점을 설명합니다. 그러나 이는 우리가 사용하는 모든 코드와 데이터를 공유하더라도 사용 가능한 소프트웨어 버전이 오류를 유발할 수 있음을 의미할 수 있습니다.
:::

이에 대한 해결책은 사용된 환경을 자세히 설명하는 것입니다.\index{재현성} 이를 수행하는 방법은 여러 가지가 있으며 복잡성을 더할 수 있습니다. 우리는 R 및 R 패키지의 사용된 버전을 문서화하고 다른 사람들이 정확한 버전을 더 쉽게 설치할 수 있도록 하는 데 중점을 둡니다. 본질적으로 우리는 재현성에 도움이 될 것이기 때문에 사용한 설정을 격리하는 것입니다 [@perkel2023]. `R`에서는 `renv`를 사용하여 이를 수행할 수 있습니다.

`renv`가 설치되고 로드되면 `init()`를 사용하여 필요한 인프라를 설정합니다.\index{효율성!재현성} 사용된 패키지와 버전을 기록할 파일을 만들 것입니다. 그런 다음 `snapshot()`을 사용하여 실제로 사용 중인 것을 문서화합니다. 이렇게 하면 정보를 기록하는 "잠금 파일"이 생성됩니다.

R 프로젝트에서 어떤 패키지를 사용하고 있는지 확인하려면 `dependencies()`를 사용할 수 있습니다. [예제 폴더](https://github.com/RohanAlexander/starter_folder)에 대해 이 작업을 수행하면 `rmarkdown`, `bookdown`, `knitr`, `rmarkdown`, `bookdown`, `knitr`, `palmerpenguins`, `tidyverse`, `renv`, `haven`, `readr`, `tidyverse` 패키지가 사용됨을 나타냅니다.

원한다면 잠금 파일("renv.lock")을 열어 정확한 버전을 확인할 수 있습니다. 잠금 파일은 설치된 다른 모든 패키지와 다운로드된 위치도 문서화합니다. 외부에서 이 프로젝트에 접근하는 사람은 `restore()`를 사용하여 우리가 사용한 패키지의 정확한 버전을 설치할 수 있습니다.

### 코드 린팅 및 스타일링

빠른 것은 가치 있지만, 주로 코드가 빠르게 실행되는 것이 아니라 빠르게 반복할 수 있는 능력에 관한 것입니다.\index{효율성!코드} @oldlanguages [p. 26]는 1954년에도 프로그래머 비용이 컴퓨터 비용만큼 들었으며, 요즘에는 추가적인 컴퓨팅 성능이 프로그래머보다 훨씬 저렴하다고 설명합니다. 성능이 좋은 코드는 중요하지만, 다른 사람의 시간을 효율적으로 사용하는 것도 중요합니다. 코드는 한 번만 작성되는 경우가 거의 없습니다. 대신 일반적으로 실수만 수정하더라도 다시 돌아와야 하며, 이는 코드가 사람에게 읽힐 수 있어야 함을 의미합니다 [@beautifulcode, p. 478]. 이렇게 하지 않으면 효율성 비용이 발생할 것입니다.

린팅\index{코드!린팅} 및 스타일링은 주로 스타일 문제에 대해 코드를 확인하고, 코드를 읽기 쉽게 재정렬하는 과정입니다. (린팅의 또 다른 측면은 닫는 괄호를 잊는 것과 같은 프로그래밍 오류를 처리하는 것이지만, 여기서는 스타일 문제에 중점을 둡니다.) 종종 가장 큰 효율성 향상은 다른 사람이 코드를 읽기 쉽게 만드는 데서 비롯됩니다. 심지어 이것이 휴식 후 코드로 돌아오는 우리 자신일지라도 말입니다. 미국 독점 거래 회사인 Jane Street\index{Jane Street}는 코드 가독성을 보장하는 데 매우 강한 초점을 맞추고 있으며, 이는 위험 완화의 핵심 부분입니다 [@minsky2011ocaml]. 우리 모두가 잠재적으로 변덕스러운 코드 관리 하에 수십억 달러를 가지고 있지는 않지만, 우리 모두는 코드가 오류를 생성하지 않는 것을 선호할 것입니다.

`lintr`의 `lint()`를 사용하여 코드를 린팅합니다. 예를 들어, 다음 R 코드를 고려하십시오 ("linting_example.R"로 저장됨).

```
#| include: true
#| message: false
#| warning: false
#| eval: false

SIMULATED_DATA <-
  tibble(
    division = c(1:150, 151),
    party = sample(
      x = c("Liberal"),
      size = 151,
      replace = T
    )
  )
```

```
#| echo: true
#| eval: false

lint(filename = "linting_example.R")
```

결과는 "linting_example.R" 파일이 열리고 `lint()`가 찾은 문제가 "마커"에 인쇄됩니다 (@fig-linter). 그런 다음 문제를 처리하는 것은 당신에게 달려 있습니다.

![예제 R 코드의 린팅 결과](figures/linter.png){#fig-linter width=90% fig-align="center"}

권장 변경 사항을 적용하면 @tidyversestyleguide 에서 정의한 모범 사례와 일치하는 더 읽기 쉬운 코드가 생성됩니다.

```
#| include: true
#| message: false
#| warning: false
#| eval: false

simulated_data <-
  tibble(
    division = c(1:150, 151),
    party = sample(
      x = c("Liberal"),
      size = 151,
      replace = TRUE
    )
  )
```

처음에는 린터\index{코드!린팅}가 식별하는 일부 측면, 예를 들어 후행 공백과 이중 따옴표만 사용하는 것이 작고 중요하지 않게 보일 수 있습니다.\index{효율성!작은 것부터 고치기} 그러나 그것들은 더 큰 문제를 해결하는 데 방해가 됩니다. 또한, 작은 것을 제대로 처리할 수 없다면, 누가 우리가 큰 것을 제대로 처리할 수 있다고 믿을 수 있겠습니까? 따라서 린터가 식별하는 모든 작은 측면을 처리하는 것이 중요합니다.

`lintr` 외에도 `styler`도 사용합니다. 이것은 린터와 달리 스타일 문제를 자동으로 조정합니다. 린터는 검토할 문제 목록을 제공했습니다. 이를 실행하려면 `style_file()`을 사용합니다.

```
#| echo: true
#| eval: false

style_file(path = "linting_example.R")
```

이렇게 하면 공백 및 들여쓰기와 같은 변경 사항이 자동으로 적용됩니다. 따라서 오류가 발생하지 않았는지 변경 사항을 검토하고 확인하기 위해 프로젝트가 끝날 때 한 번만 하는 것이 아니라 정기적으로 수행해야 합니다.


### 코드 검토

이러한 스타일 측면을 모두 처리한 후 코드 검토\index{코드!검토}\index{효율성!코드 검토}로 넘어갈 수 있습니다. 이는 다른 사람이 코드를 검토하고 비판하는 과정입니다. 많은 전문 작가들은 편집자를 가지고 있으며, 코드 검토는 데이터 과학에서 이에 가장 가깝습니다. 코드 검토는 코드 작성의 중요한 부분이며, @researchsoftware [p. 465]는 이를 "버그를 찾는 가장 효과적인 방법"이라고 설명합니다. 특히 코딩을 배울 때 피드백을 받는 것이 개선에 큰 도움이 되기 때문에 매우 유용하지만, 상당히 부담스러울 수 있습니다.

다른 사람의 코드를 검토할 때 정중하고 협력적인 태도를 취하십시오.\index{도움말!제공} 공백 및 구분과 같은 스타일과 관련된 작은 측면은 린터와 스타일러가 처리했어야 하지만, 그렇지 않은 경우 이에 대한 일반적인 권장 사항을 제시하십시오. 데이터 과학에서 코드 검토자로서 대부분의 시간은 다음과 같은 측면에 할애해야 합니다.

1) 정보가 담긴 README가 있습니까? 어떻게 개선할 수 있습니까?
2) 파일 이름과 변수 이름이 일관되고, 정보가 담겨 있으며, 의미가 있습니까?
3) 주석을 통해 무엇이 수행되고 있는지 이해할 수 있습니까?
4) 테스트가 적절하고 충분합니까? 고려되지 않은 예외적인 경우나 코너 솔루션이 있습니까? 마찬가지로, 불필요한 테스트가 제거될 수 있습니까?
5) 변수로 변경하고 설명할 수 있는 매직 넘버가 있습니까?
6) 변경할 수 있는 중복 코드가 있습니까?
7) 해결해야 할 미해결 경고가 있습니까?
8) 더 작은 함수로 분리할 수 있는 특히 큰 함수나 파이프가 있습니까?
9) 프로젝트의 구조가 적절합니까?
10) 코드를 데이터로 변경할 수 있습니까 [@researchsoftware, p. 462]?

예를 들어, 총리와 대통령의 이름을 찾는 코드를 고려해 봅시다. 이 코드를 처음 작성했을 때 관련 이름을 코드에 직접 추가했을 것입니다. 그러나 코드 검토의 일부로, 이를 변경하도록 권장할 수 있습니다. 관련 이름의 작은 데이터 세트를 만들고, 해당 데이터 세트를 조회하도록 코드를 다시 작성하도록 권장할 수 있습니다.

코드 검토는 코드가 적어도 한 명의 다른 사람에게 이해될 수 있도록 보장합니다. 이는 세상에 대한 지식을 구축하는 데 중요한 부분입니다. Google\index{Google}에서 코드 검토는 주로 결함을 찾는 것이 아니라, 가독성과 유지 보수성을 보장하고 교육을 제공하는 것입니다 [@codereview]. Jane Street\index{Jane Street}에서도 마찬가지입니다. 그들은 코드 검토를 사용하여 버그를 잡고, 기관 지식을 공유하고, 교육을 지원하며, 직원이 읽을 수 있는 코드를 작성하도록 의무화합니다 [@ocamlyaronpodcast].

마지막으로, 코드 검토는 번거롭고 하루 종일 걸리는 모든 코드를 읽는 과정이 될 필요도 없고 되어서도 안 됩니다. 최고의 코드 검토는 단 하나의 파일에 대한 빠른 검토이며, 몇 줄의 변경 사항을 제안하는 데 중점을 둡니다. 실제로 한 명의 개인이 아닌 소규모 팀이 검토하는 것이 더 나을 수 있습니다. 한 번에 너무 많은 코드를 검토하지 마십시오. 최대 몇 백 줄 정도이며, 이는 약 한 시간이 걸려야 합니다. 그 이상은 효율성 감소와 관련이 있는 것으로 밝혀졌기 때문입니다 [@cohen2006best, p. 79].

### 코드 리팩토링

코드를 리팩토링한다는 것은 새 코드가 이전 코드와 동일한 결과를 달성하지만, 새 코드가 더 잘 수행하도록 다시 작성하는 것을 의미합니다.\index{효율성!코드} 예를 들어, @refactornature는 중요한 영국 코로나 모델의 기반이 되는 코드가 처음에 역학자들에 의해 작성되었으며,\index{역학} 몇 달 후 왕립 학회, Microsoft 및 GitHub 팀에 의해 명확하고 정리되었다고 논의합니다. 이는 두 버전 모두 동일한 입력이 주어졌을 때 동일한 출력을 생성했음에도 불구하고 모델에 대한 더 많은 신뢰를 제공했기 때문에 가치 있었습니다.\index{신뢰!확립}

우리는 일반적으로 다른 사람이 작성한 코드와 관련하여 코드 리팩토링을 언급합니다. (비록 우리가 실제로 코드를 작성했지만, 그것이 오래 전의 일일 수도 있습니다.) 코드를 리팩토링하기 시작할 때, 다시 작성된 코드가 원본 코드와 동일한 결과를 달성하는지 확인하고 싶습니다. 이는 우리가 의존할 수 있는 적절한 테스트 스위트가 작성되어 있어야 함을 의미합니다. 이러한 테스트가 존재하지 않는다면, 우리는 그것들을 생성해야 할 수도 있습니다.\index{코드!테스트}

우리는 다른 사람들이 더 쉽게 이해할 수 있도록 코드를 다시 작성하며, 이는 우리의 결론에 대한 더 많은 신뢰를 가능하게 합니다.\index{신뢰!확립} 그러나 그렇게 하기 전에 기존 코드가 무엇을 하는지 이해해야 합니다. 시작하는 한 가지 방법은 코드를 살펴보고 광범위한 주석을 추가하는 것입니다. 이러한 주석은 일반적인 주석과 다릅니다. 이는 각 코드 청크가 무엇을 하려고 하는지, 그리고 어떻게 개선될 수 있는지 이해하려는 우리의 적극적인 과정입니다.

코드 리팩토링은 코드가 모범 사례를 충족하는지 확인할 수 있는 기회입니다.\index{코드!모범 사례} @Trisovic2022는 9,000개의 R 스크립트를 검토한 결과 다음과 같은 핵심 권장 사항을 제시합니다.

1. `setwd()` 및 모든 절대 경로를 제거하고, ".Rproj" 파일과 관련된 상대 경로만 사용하도록 합니다.
2. 명확한 실행 순서가 있는지 확인합니다. 처음에는 파일 이름에 숫자를 사용하여 이를 달성하도록 권장했지만, 결국에는 `targets` [@targets]와 같은 더 정교한 접근 방식을 대신 사용할 수 있습니다.
3. 코드가 다른 컴퓨터에서 실행될 수 있는지 확인합니다.

예를 들어, 다음 코드를 고려하십시오.

```
#| eval: false

setwd("/Users/rohanalexander/Documents/telling_stories")

library(tidyverse)

d = read_csv("cars.csv")

mtcars =
  mtcars |>
  mutate(K_P_L = mpg / 2.352)

library(datasauRus)

datasaurus_dozen
```

R 프로젝트를 생성하여 `setwd()`를 제거하고, 모든 `library()` 호출을 맨 위에 그룹화하고, "=" 대신 "<-"를 사용하고, 변수 이름을 일관되게 유지하여 변경할 수 있습니다.

```
#| eval: false

library(tidyverse)
library(datasauRus)

cars_data <- read_csv("cars.csv")

mpg_to_kpl_conversion_factor <- 2.352

mtcars <-
  mtcars |>
  mutate(kpl = mpg / mpg_to_kpl_conversion_factor)
```


## 결론

이 장에서는 많은 것을 고려했으며, 압도되는 것은 정상입니다. 필요에 따라 Quarto 섹션으로 돌아오십시오. 많은 사람들이 Git과 GitHub에 대해 혼란스러워하며, 그저 필요한 만큼만 알고 있습니다. 그리고 효율성에 대한 많은 자료가 있었지만, 성능이 좋은 코드의 가장 중요한 측면은 다른 사람이 읽기 쉽게 만드는 것입니다. 심지어 그 사람이 휴식 후 돌아온 당신 자신일지라도 말입니다.


## 연습 문제

### 실습 {.unnumbered}

1. *(계획)* 다음 시나리오를 고려하십시오: *어떤 나라에서는 의회에서 의석을 얻을 수 있는 정당이 항상 네 개뿐입니다. 주어진 의석과 관련된 지역에서 가장 많은 표를 얻은 후보가 그 의석을 차지합니다. 의회는 총 175석으로 구성됩니다. 한 분석가는 의석별 각 정당의 득표수에 관심이 있습니다.* 데이터 세트가 어떻게 생겼을지 스케치하고, 모든 관측치를 보여주기 위해 만들 수 있는 그래프를 스케치하십시오.
2. *(시뮬레이션)* 설명된 시나리오를 더 자세히 고려하고 상황을 시뮬레이션하십시오. 아래 코드를 사용하여 적절한 상황을 신중하게 지정하십시오. 그런 다음 시뮬레이션된 데이터를 기반으로 다섯 가지 테스트를 작성하십시오.

```
#| eval: false
#| echo: true

library(tidyverse)

election_results <-
  tibble(
    seat = rep(1:175, each = 4),
    party = rep(x = 1:4, times = 175),
    votes = runif(n = 175 * 4, min = 0, max = 1000) |> floor()
  )
```

3. *(획득)* 관심 있는 국가의 실제 투표 데이터 소스를 지정하십시오.
4. *(탐색)* 다음 코드로 시작하여 각 정당이 얻은 의석 수 표를 만드십시오.

```
#| eval: false
#| echo: true

library(tidyverse)

election_results |>
  slice_max(votes, n = 1, by = seat) |>
  count(party) |>
  tt()
```

5. *(공유)* 식별한 소스에서 데이터를 수집한 것처럼 (시뮬레이션된 것이 아니라) 그리고 시뮬레이션된 데이터를 사용하여 만든 표가 실제 상황을 반영한 것처럼 두 단락을 작성하십시오. 단락에 포함된 정확한 세부 정보는 사실일 필요는 없지만 합리적이어야 합니다 (즉, 실제로 데이터를 얻거나 그래프를 만들 필요는 없습니다). 코드를 R 파일과 Quarto 문서로 적절하게 분리하십시오. README가 있는 GitHub 저장소 링크를 제출하십시오.

### 퀴즈 {.unnumbered}

1. @Gelman2016 에 따르면, 연구자들이 데이터 분석의 유연성을 이용하여 유의미한 결과를 찾는 통계적 개념은 무엇입니까 (하나 선택)?
    a. 무작위 표본 추출.
    b.  P-해킹.
    c. 귀무 가설 검정.
    d. 베이즈 추론.
2. @Gelman2016 에 따르면, "p-해킹"은 무엇입니까 (하나 선택)?
    a. p-값을 수정하는 방법.
    b.  유의미하지 않은 결과가 유의미해질 때까지 데이터 또는 분석을 조작하는 것.
    c. 계산 효율성을 향상시키는 기술.
    d. 데이터 공유에 대한 윤리적 접근 방식.
3. @Gelman2016 에 따르면, 파일 서랍 문제(file drawer problem)는 무엇입니까 (하나 선택)?
    a.  유의미한 결과만 출판하여 발생하는 편향.
    b. 보관된 데이터에 접근하기 어려움.
    c. 데이터 코딩 및 입력 오류.
    d. 오래된 실험을 복제하는 데 어려움.
4. @Gelman2016 에 따르면, 긍정적인 결과만 출판하려는 경향을 나타내는 용어는 무엇입니까 (하나 선택)?
    a. 데이터 마이닝.
    b.  출판 편향.
    c. 확증 편향.
    d. 표본 오차.
5. @Gelman2016 에 따르면, 연구자들이 동일한 데이터로 유의미한 결과를 얻을 수 있도록 하는 데이터 분석에서 가질 수 있는 수많은 선택을 설명하는 용어는 무엇입니까 (하나 선택)?
    a.  연구자 자유도.
    b. 데이터 마이닝.
    c. 표본 편향.
    d. 효과 크기 조작.
6. @Gelman2016 에 따르면, 갈림길의 정원(garden of forking paths)은 어떤 문제를 나타냅니까 (하나 선택)?
    a. 기계 학습에서 의사 결정 트리의 복잡성.
    b.  동일한 데이터로 수행할 수 있는 여러 잠재적 분석.
    c. 시간이 지남에 따라 이론과 응용 작업의 분기.
    d. 학문 분야의 분기.
7. @Gelman2016 에 따르면, 연구에서 "복제"는 무엇입니까 (하나 선택)?
    a.  새로운 데이터를 사용하여 원본 결과를 재현하는 연구.
    b. 이전 방법론을 비판하는 연구.
    c. 여러 연구의 메타 분석.
    d. 원본 연구 논문의 정확한 복사본.
8. @Gelman2016 에 따르면, 사회 과학에서 재현 불가능한 결과에 기여하는 요인은 무엇입니까 (하나 선택)?
    a. 부적절한 표본 크기.
    b. 고급 통계 소프트웨어 부족.
    c.  선택적 보고로 이어지는 연구자 자유도.
    d. 질적 데이터에 대한 과도한 의존.
9. @Gelman2016 에 따르면, 복제 위기(replication crisis)는 무엇을 의미합니까 (하나 선택)?
    a. 새로운 이론을 만드는 데 어려움.
    b. 유사한 연구의 과잉 생산.
    c.  이전 연구 결과의 복제에 어려움.
    d. 실험 참가자 부족.
10. @Gelman2016 에 따르면, 복제 위기를 완화하는 데 도움이 되는 것은 무엇입니까 (하나 선택)?
    a. 데이터 기밀 유지.
    b. 유의미한 결과만 출판.
    c.  연구 및 분석 계획 사전 등록.
    d. 독점 소프트웨어 사용 증가.
11. @Gelman2016 은 심리학의 복제 위기에 초점을 맞춥니다. 자신의 경험, 아마도 다른 수업에서 얻은 경험을 바탕으로 다른 학문 분야를 선택하고, 해당 학문 분야에서 복제 문제가 있을 수 있다고 생각하는 정도와 그 이유에 대해 작성하십시오.
12. 익숙한 학문 분야를 선택하십시오. 해당 분야에서 재현성을 향상시킬 수 있는 관행은 무엇입니까? 간략하게 설명하십시오.
13. @wilsongoodenough 에 따르면, 다음 중 중요한 데이터 관리 관행은 무엇입니까 (모두 선택)?
    a.  원본 데이터와 정리된 버전 모두 저장.
    b.  데이터 처리 단계 문서화.
    c.  데이터 저장에 비독점 파일 형식 사용.
14. @wilsongoodenough 에 따르면, 프로젝트의 홈 디렉토리에 README 파일을 만드는 것이 왜 중요합니까 (하나 선택)?
    a. 원본 데이터 파일을 저장하기 위해.
    b.  프로젝트의 목적을 설명하고 개요를 제공하기 위해.
    c. 프로젝트의 모든 오류 및 버그를 나열하기 위해.
    d. 프로젝트 파일의 모든 버전을 추적하기 위해.
15. @wilsongoodenough 에 따르면, 버전 제어를 사용하는 주요 이점은 무엇입니까 (하나 선택)?
    a. 연구자를 위해 코드를 자동으로 작성합니다.
    b.  변경 사항을 추적하고 협업을 돕습니다.
    c. 데이터 백업의 필요성을 대체합니다.
    d. 모든 데이터가 암호화되도록 보장합니다.
16. @wilsongoodenough 에 따르면, 프로젝트에서 파일 이름을 지정하는 권장 관행은 무엇입니까 (하나 선택)?
    a.  파일 이름에 내용 또는 기능을 반영합니다.
    b. result1.csv, result2.csv와 같은 순차 번호 사용.
    c. 파일 이름을 고유하게 만들기 위해 특수 문자 포함.
    d. 파일 이름에 공백 및 구두점 사용.
17. @wilsongoodenough 에 따르면, 원본 데이터의 수정되지 않은 복사본을 저장해야 하는 이유는 무엇입니까 (하나 선택)?
    a. 데이터 저장 공간을 보존하기 위해.
    b. 법적 규정을 준수하기 위해.
    c.  확인 및 재현성을 위한 변경되지 않은 소스를 보장하기 위해.
    d. 소프트웨어 업데이트와의 호환성을 유지하기 위해.
18. @wilsongoodenough 에 따르면, 개방형 파일 형식을 사용하는 주요 이점은 무엇입니까 (하나 선택)?
    a. 처리 속도가 더 빠릅니다.
    b.  독점 소프트웨어 없이 접근 가능합니다.
    c. 데이터를 더 효율적으로 압축합니다.
    d. 데이터 보안을 강화합니다.
19. @wilsongoodenough 에 따르면, 데이터 파일을 구성할 때 권장되는 관행은 무엇입니까 (모두 선택)?
    a.  의미 있고 일관된 파일 이름 사용.
    b. 모든 파일을 단일 폴더에 저장.
    c.  파일을 명확한 디렉토리 구조로 구성.
    d. 버전 추적을 위해 파일 이름에 날짜 포함.
20. @wilsongoodenough 에 따르면, 데이터 처리 단계를 문서화하는 것이 왜 중요합니까 (하나 선택)?
    a. 데이터 분석 속도를 높입니다.
    b. 데이터 암호화에 도움이 됩니다.
    c. 저장 요구 사항을 줄입니다.
    d.  다른 사람들이 분석을 이해하고 재현할 수 있도록 합니다.
21. 재현성의 이점은 무엇입니까?
    a.  결과를 독립적으로 확인할 수 있습니다.
    b. 코드 실행 속도를 높입니다.
    c. 데이터 시각화를 더 쉽게 만듭니다.
    d. 문서화 필요성을 줄입니다.
22. @Alexander2019 에 따르면, 연구는 다음의 경우 재현 가능합니다 (하나 선택)?
    a. 동료 심사 저널에 출판됩니다.
    b. 연구에 사용된 모든 자료가 제공됩니다.
    c. 저자가 자료를 제공하지 않아도 정확히 재현될 수 있습니다.
    d.  연구에 사용된 모든 자료가 주어졌을 때 정확히 재현될 수 있습니다.
23. 문학적 프로그래밍은 무엇입니까 (하나 선택)?
    a. 코드와 문서를 다른 파일로 분리합니다.
    b. 코드의 구문 오류를 자동으로 수정합니다.
    c. 코드 문서 생성을 자동화합니다.
    d.  동일한 문서에 코드와 자연어를 통합합니다.
24. 재현 가능한 워크플로우에서 git의 주요 기능은 무엇입니까 (하나 선택)?
    a. 데이터 정리를 자동화합니다.
    b. 코드를 병렬로 실행합니다.
    c. 데이터 시각화를 보고서에 통합합니다.
    d.  코드에 대한 버전 제어 시스템을 제공합니다.
25. @tidyversestyleguide 에 따르면, "00_get_data.R" 및 "get data.R" 파일은 어떻게 분류됩니까 (하나 선택)?
    a. 나쁨; 나쁨.
    b.  좋음; 나쁨.
    c. 나쁨; 좋음.
    d. 좋음; 좋음.
26. 재현 가능한 연구를 위해 Quarto를 사용하는 이점은 무엇입니까 (하나 선택)?
    a. 통계 분석을 자동화합니다.
    b.  코드와 텍스트를 통합합니다.
    c. 버전 제어의 필요성을 대체합니다.
    d. 데이터 시각화 기능을 향상시킵니다.
27. Quarto에서 최상위 제목을 어떻게 나타냅니까 (하나 선택)?
    a. ### 제목
    b. **제목**
    c.  # 제목
    d. - 제목
28. 다음 중 Quarto에서 굵은 텍스트를 생성하는 것은 무엇입니까 (하나 선택)?
    a.  `**굵게**`
    b. `##굵게##`
    c. `*굵게*`
    d. `#굵게#`
29. Quarto R 코드 청크에서 "echo" 옵션은 무엇을 합니까 (하나 선택)?
    a. 코드 출력을 억제하기 위해.
    b.  코드가 문서에 표시될지 여부를 제어하기 위해.
    c. 코드를 조건부로 평가하기 위해.
    d. 출력에 경고를 포함하기 위해.
30. Quarto R 청크에서 경고를 숨기는 옵션은 무엇입니까 (하나 선택)?
    a. `echo: false`
    b. `eval: false`
    c.  `warning: false`
    d. `message: false`
31. R 코드 청크를 실행하고 결과를 표시하지만, Quarto R 청크에서 코드를 표시하지 않는 옵션은 무엇입니까 (하나 선택)?
    a.  `echo: false`
    b. `include: false`
    c. `eval: false`
    d. `warning: false`
    e. `message: false`
32. R 프로젝트가 중요한 이유는 무엇입니까 (모두 선택)?
    a.  재현성에 도움이 됩니다.
    b.  코드를 더 쉽게 공유할 수 있습니다.
    c.  작업 공간을 더 체계적으로 만듭니다.
33. R 프로젝트 이름이 저장소의 내용을 반영하는 것이 왜 중요합니까 (모두 선택)?
    a.  일관성.
    b.  전문성.
    c.  세부 사항에 대한 주의.
34. 패키지와 데이터 세트가 로드되었다고 가정할 때, 이 코드에서 무엇이 잘못되었습니까: `DoctorVisits |> filter(visits)` (하나 선택)?
    a. `DoctorVisits`
    b. `|>`
    c.  `filter`
    d. `visits`
35. reprex는 무엇이며, reprex를 만들 수 있는 것이 왜 중요합니까 (모두 선택)?
    a.  오류를 재현할 수 있도록 하는 재현 가능한 예제.
    b.  다른 사람들이 당신을 돕도록 돕는 재현 가능한 예제.
    c.  구축 과정에서 자신의 문제를 해결할 수 있는 재현 가능한 예제.
    d.  자신을 돕기 위해 실제로 노력했음을 보여주는 재현 가능한 예제.
36. @sharlatalks 에 따르면, "막힌 것을 해결하는 데 도움이 필요하다면, 첫 번째 단계는 reprex, 즉 재현 가능한 예제를 만드는 것입니다. reprex의 목표는 다른 사람들이 실행하고 당신의 고통을 느낄 수 있도록 문제 있는 코드를 패키징하는 것입니다. 그러면 바라건대, 그들이 해결책을 제공하고 당신의 고통을 끝낼 수 있을 것입니다."에서 핵심 부분은 무엇입니까 (하나 선택)?
    a. 문제 있는 코드를 패키징합니다.
    b.  다른 사람들이 실행하고 당신의 고통을 느낄 수 있습니다.
    c. 첫 번째 단계는 reprex를 만드는 것입니다.
    d. 그들이 해결책을 제공하고 당신의 고통을 끝낼 수 있습니다.
37. @sharlatalks 에 따르면, 도움을 구할 때 재현 가능한 예제를 만드는 것이 왜 중요합니까 (하나 선택)?
    a. 문서화 필요성을 줄입니다.
    b. 코딩 기술을 보여줍니다.
    c.  다른 사람들이 문제를 재현하고 해결책을 제공할 수 있도록 합니다.
    d. 소프트웨어 라이선스를 준수합니다.
38. 다른 사람과 협업할 때 코드의 효율성을 높이는 관행은 무엇입니까 (하나 선택)?
    a. 절대 파일 경로 사용.
    b.  명확한 주석 및 문서 작성.
    c. 함수 사용 최소화.
    d. 지적 재산을 보호하기 위해 코드 난독화.
39. 다음 중 버전 제어를 위해 Git을 사용하는 이점은 무엇입니까 (모두 선택)?
    a.  시간 경과에 따른 변경 사항 추적.
    b.  여러 사용자 간의 협업 촉진.
    c. 데이터 백업 자동화.
    d. 코드 실행 속도 향상.
40. `R` 스크립트에서 `setwd()` 사용을 피하는 이유는 무엇입니까 (하나 선택)?
    a. 코드 실행 속도를 늦출 수 있습니다.
    b. 관리자 권한이 필요합니다.
    c.  코드를 덜 이식 가능하고 재현 가능하게 만듭니다.
    d. 최근 R 버전에서 더 이상 사용되지 않습니다.
41. 재현성의 맥락에서 `renv` 패키지의 기능은 무엇입니까 (하나 선택)?
    a. 코드 청크를 병렬로 실행하기 위해.
    b.  소프트웨어 환경을 문서화하고 공유하기 위해.
    c. 코드 린팅을 자동화하기 위해.
    d. 시뮬레이션에서 코드 효율성을 향상시키기 위해.
42. 다음 중 재현 가능한 워크플로우에 기여하지 않는 것은 무엇입니까 (하나 선택)?
    a.  작업 디렉토리를 설정하기 위해 `setwd()` 사용.
    b. 결과뿐만 아니라 코드와 데이터 공유.
    c. 논문에서 R 및 Python 코드를 통합하기 위해 Quarto 사용.
    d. Git 및 GitHub를 사용한 버전 제어.
43. @tidyversestyleguide에 따르면, 다음 변수 이름 중 권장 스타일을 따르는 것은 무엇입니까 (하나 선택)?
    a. total-Sales
    b. TotalSales
    c.  total_sales
    d. total sales
44. `R`에서 `lintr` 패키지의 주요 기능은 무엇입니까 (하나 선택)?
    a. 알고리즘의 논리적 오류를 찾기 위해.
    b. 코드를 더 빠르게 실행하기 위해.
    c.  스타일 일관성을 위한 코드 린팅을 제공하기 위해.
    d. 데이터 분포를 시각화하기 위해.
45. 코드 리팩토링은 무엇입니까 (하나 선택)?
    a. 오류를 수정하기 위해 코드를 디버깅하는 것.
    b.  동작을 변경하지 않고 구조를 개선하기 위해 코드를 다시 작성하는 것.
    c. 기존 코드에 새로운 기능을 추가하는 것.
    d. 코드를 한 언어에서 다른 언어로 변환하는 것.
46. 코드에서 "매직 넘버"를 피해야 하는 이유는 무엇입니까 (하나 선택)?
    a. 실행 속도를 늦춥니다.
    b.  코드 가독성 및 유지 보수성을 저하시킵니다.
    c. 특정 소프트웨어와 호환되지 않습니다.
    d. 구문 오류를 유발합니다.
47. 코드를 작성할 때 린터를 사용하는 주된 목적은 무엇입니까 (하나 선택)?
    a. 알고리즘의 논리적 오류를 찾기 위해.
    b. 코드를 더 빠르게 실행하기 위해.
    c.  코딩 스타일 지침을 적용하기 위해.
    d. 코드를 기계어로 컴파일하기 위해.
48. 재현성의 맥락에서 "미래의 당신"은 무엇을 의미합니까 (하나 선택)?
    a. 자동화된 코드 생성.
    b.  나중에 코드를 이해하고 재사용할 수 있는 능력.
    c. 코드의 예측 분석.
    d. 미래 동료와의 협업.


### 수업 활동 {.unnumbered}

- [시작 폴더](https://github.com/RohanAlexander/starter_folder)를 사용하여 새 저장소를 만드십시오. 수업의 공유 Google 문서에 GitHub 저장소 링크를 추가하십시오.
- Quarto를 사용하여 제목, 저자 및 초록이 있는 PDF를 만드십시오.^[PDF를 로컬에서 설정하는 데 어려움을 겪는 소수의 학생들이 항상 있습니다. 최악의 경우, 다른 모든 것을 HTML로 로컬에서 수행한 다음 Posit Cloud에서 PDF를 빌드하십시오.]
- 세 섹션을 추가하고 `palmerpenguins::penguins`에 대해 종별 부리 길이 평균을 생성하는 코드를 추가하십시오 (코드 자체는 숨겨져 있음).
- R 및 `palmerpenguins`의 인용을 추가한 다음 성별 체질량 그래프를 추가하십시오.
- 그래프에 대한 텍스트 단락과 상호 참조를 추가하십시오. 또한 연도별 종 수에 대한 표를 추가하십시오.
- [강사는 (매우 천천히) 이 모든 것을 라이브 코딩하고 학생들이 코딩을 따라하도록 해야 합니다.] 로컬 컴퓨터에 git을 설정하십시오.^[GitHub 이메일을 숨겼다면 로컬에서 이메일 주소를 추가할 때 별칭을 사용해야 합니다.] GitHub 저장소를 만든 다음 로컬 복사본을 만들고 일부 변경 사항을 적용한 다음 푸시하십시오.^[git이 로컬에서 작동하지 않는 소수의 학생들이 항상 있을 것입니다. 저는 가장 좋은 접근 방식은 시연하는 동안 고급 학생과 짝을 지어 분류하고, 문제가 남아 있으면 사무실 시간 동안 개별적으로 처리하는 것이라고 생각합니다.]
- 파트너의 GitHub 저장소를 찾아 포크하고 변경 사항을 적용한 다음 풀 리퀘스트를 만드십시오.
- 다음 코드는 오류를 생성합니다. @sec-dealingwitherrors의 전략을 따라 수정하십시오.
```
#| eval: false

tibble(year = 1875:1972,
       level = as.numeric(datasets::LakeHuron)) |>
  ggplot(aes(x = year, y = level)) |>
  geom_point()
```
- 다음 코드는 오류를 생성합니다. @sec-dealingwitherrors의 전략을 따라 수정하십시오.
```
#| eval: false

tibble(year = 1871:1970,
       annual_nile_flow = as.character(datasets::Nile)) |>
  ggplot(aes(x = annual_nile_flow)) +
  geom_histogram()
```
- 다음 코드는 오류를 생성합니다. @sec-omgpleasemakeareprexplease를 따라 reprex를 만들고 (`mtcars`와 같은 더 일반적인 데이터 세트를 사용하도록 예제를 변경), GitHub Gist에 추가한 다음 강사에게 이메일을 보내십시오.
```
#| eval: false

tibble(year = 1875:1972,
       level = as.numeric(datasets::LakeHuron)) |>
  ggplot(aes(x = year, y = level)) |>
  geom_point()
```
- 다음 코드는 오류를 생성합니다. ChatGPT 또는 동등한 LLM을 사용하여 수정하십시오. 다음을 논의하십시오: 1) 프롬프트, 2) 수정된 코드.
```
#| eval: false

penguins |>
  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, color = species)) |>
  geom_point()
```


### 과제 I {.unnumbered}

이 과제의 목적은 동료 검토를 주고받는 것입니다. 일반적으로 동료 검토, 특히 코드 검토 [@codereview]는 전문가로서 일하는 데 중요한 부분입니다.

`usethis::git_vaccinate()`를 실행하여 시작하십시오. 그런 다음 @sec-fire-hose 의 활동에서 작업한 내용을 [시작 폴더](https://github.com/rohanalexander/starter_folder)를 사용하도록 업데이트하십시오. 여기에는 무엇보다도 다운로드 및 정리를 적절한 스크립트로 이동하고, README를 업데이트하고, 제목을 추가하는 등이 포함됩니다. 일반적으로 [온라인 부록 -@sec-papers]의 *Donaldson* 논문 채점 기준표를 살펴보고, 추가 작업을 너무 많이 하지 않고 가능한 한 많이 준수하도록 노력해야 합니다. 그런 다음 다른 사람과 교환하십시오.

@googlecoderview 및 @giladpeerreview 를 읽으십시오. 그런 다음 GitHub Issues를 사용하여 저장소 내용에 대한 동료 검토를 수행하십시오. @giladpeerreview 에 따라 동료 검토는 다음 구조를 사용하고 깔끔하게 서식이 지정되어야 합니다.

1. 요약
    *[검토 중인 원고에 대한 간략한 요약을 추가하십시오.]*
2. 강력한 긍정적 측면:
    *[간략하게 작성하십시오. 두세 개의 점을 찍으십시오.]*
3. 필요한 중요한 개선 사항:
    *[이것이 가장 중요한 섹션입니다. 이것은 논문 저자가 수정하고/하거나 해결해야 하는 문제입니다. 매우 건설적이고 정중하며, 부드럽지만 명확하게 작성하고, 저자를 돕기 위해 가능한 한 많은 정보를 제공하십시오. 여기에는 실수/오류, 누락된 정보, 간과, 오해 등이 포함될 수 있습니다. 가능하다면 왜 이러한 것들이 실수인지 설명하고, 수정 사항 또는 올바른 정보를 찾을 수 있는 링크를 제공하십시오.]*
4. 개선을 위한 제안:
    *[이것은 저자가 더 잘할 수 있도록 돕기 위한 것입니다. 당신이 확실하지 않은 것에 대해 언급하거나 의견을 진술하거나, 오타 또는 사소한 코드 문제를 지적할 수 있지만, 이것이 제안임을 겸손하게 받아들이고 매우 긍정적이고 건설적으로 작성하십시오. 약 5~6개의 점이 있어야 합니다.]*
5. 평가:
    *[채점 기준표의 각 요소를 추가하고, 각 요소에 대한 의견과 점수를 제공하십시오. 이것은 채점에 사용되지 않으며, 저자에게 각 요소를 개선하기 위해 얼마나 많은 노력을 기울여야 하는지에 대한 아이디어를 제공하기 위한 것입니다.]*
6. 예상 총점:
    *[X]* / *[Y]*.
7. 기타 의견:
    *[기타 의견.]*


### 과제 II {.unnumbered}

이 과제의 목적은 다음을 편안하게 다루는 것입니다.

1. Quarto, 그리고
2. Git 및 GitHub.

웹사이트는 커뮤니케이션의 중요한 부분입니다. 예를 들어, 작업 포트폴리오를 공개적으로 사용할 수 있는 장소입니다. 웹사이트를 만드는 한 가지 방법은 Quarto의 내장 웹사이트를 사용하는 것입니다. RStudio에서 GitHub를 설정하면 약 5분 안에 웹사이트를 온라인에 게시할 수 있습니다.

새 프로젝트를 생성하여 시작하십시오 ("파일" -> "새 프로젝트" -> "새 디렉토리" -> "Quarto 웹사이트"). 이름을 지정하고 "새 세션에서 열기" -> "프로젝트 생성"을 선택하십시오 (@fig-quartoone).

:::{#fig-quartowebsiteftw layout-nrow="2" layout-valign="bottom"}

![Quarto 웹사이트 설정을 위한 예제 설정](figures/quartoone.png){#fig-quartoone}

![Quarto 웹사이트 구축](figures/quartotwo.png){#fig-quartotwo}

![Quarto 웹사이트 개인화](figures/quartothree.png){#fig-quartothree}

![Quarto yaml 업데이트](figures/quartofour.png){#fig-quartofour}

Quarto를 사용하여 웹사이트 만들기
:::

기본 웹사이트는 "빌드" -> "웹사이트 렌더링"으로 생성할 수 있습니다 (@fig-quartotwo). 기본적으로 "뷰어" 창에 표시될 수 있지만, 새 창에서도 표시될 수 있습니다. 이 시점에서 우리는 자신의 세부 정보를 반영하도록 변경하고 싶을 수 있습니다. 특히, "index.qmd"의 제목을 변경하고 자신의 세부 정보를 추가하고 싶을 수 있습니다 (@fig-quartothree).

기본 메뉴에 포함된 내용은 "_quarto.yml"에 지정됩니다. "contact.qmd"와 같은 다른 페이지를 추가할 수 있으며, 포함될 내용을 생성하려면 "about.qmd"를 복제한 다음 편집하고 싶을 수 있습니다 (@fig-quartofour). "_quarto.yml"에서 변경할 수 있는 또 다른 측면은 테마입니다. 기본값은 "cosmo"이지만, [여기](https://quarto.org/docs/output-formats/html-themes.html)에 지정된 다른 많은 옵션이 있습니다.

세부 정보가 개인화되고 웹사이트에 불만이 없으면 GitHub로 푸시한 다음 GitHub Pages로 호스팅할 수 있습니다. 이를 활용하려면 먼저 두 가지를 수행해야 합니다. 첫째, "_quarto.yml"을 약간 수정하여 "_site" 대신 "docs" 폴더로 빌드하도록 지정해야 합니다 (@fig-quartofour).

```
#| eval: false
#| echo: true

project:
  type: website
  output-dir: docs
```

알아야 할 다른 측면은 이 서비스를 사용할 때 기본적으로 GitHub가 사이트를 빌드하려고 시도한다는 것입니다. 이는 우리가 원하지 않는 것이므로, 먼저 숨겨진 파일을 추가하여 이를 끄려면 콘솔에서 다음을 실행해야 합니다.

```
#| eval: false
#| echo: true

file.create(".nojekyll")
```

그런 다음 GitHub가 설정되었다고 가정하고 `usethis`를 사용하여 새로 생성된 프로젝트를 GitHub에 올릴 수 있습니다. `use_git()`을 사용하여 Git 저장소를 초기화한 다음 `use_github()`가 GitHub로 푸시합니다.

```
#| eval: false
#| echo: true

use_git()
use_github()
```

프로젝트는 GitHub에 있을 것입니다. GitHub Pages를 사용하여 호스팅할 수 있습니다: "설정 -> 페이지"로 이동한 다음 설정에 따라 소스를 "main" 또는 "master"로 변경하고 마지막으로 "docs"로 변경합니다. 몇 분 동안 다양한 검사를 실행한 후 GitHub는 사이트를 방문할 수 있는 주소를 알려줄 것입니다.

사이트를 업데이트하려면 로컬에서 작업하십시오. 먼저 풀하여 GitHub에서 변경된 내용이 로컬에 있는지 확인한 다음 사이트를 편집하고 다시 렌더링한 다음 일반적인 방식으로 GitHub에 푸시하십시오. 검사가 완료되면 라이브 웹사이트가 업데이트됩니다.

웹사이트에 일반 텍스트 단락, 섹션 제목, 글머리 기호가 포함되어 있는지 확인하십시오. 모든 것이 잘 문서화되고 깔끔하게 서식이 지정되어야 하며 전반적으로 고품질이어야 합니다.

관련된 채점 기준표 구성 요소는 "수업 논문", "LLM 사용 문서화", "산문", "커밋", "재현 가능한 워크플로우"입니다. 웹사이트 링크를 제출하십시오.


### 논문 {.unnumbered}

:::{.content-visible when-format="pdf"}
이 시점에서 [온라인 부록 "논문"](https://tellingstorieswithdata.com/23-assessment.html)의 *Donaldson* 논문이 적절할 것입니다.
:::

:::{.content-visible unless-format="pdf"}
이 시점에서 [온라인 부록 -@sec-papers]의 *Donaldson* 논문이 적절할 것입니다.
:::
